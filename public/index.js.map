{"version":3,"file":"index.js","sources":["../../futils/dist/index.js","../src/boids.js","../src/index.js"],"sourcesContent":["function isPrimitiveTypeEx(typeString) {\n  return typeString === 'integer'\n    || typeString === 'number'\n    || typeString === 'string'\n    || typeString === 'boolean';\n}\n\nfunction isPrimitiveType(obj) {\n  const tp = typeof obj;\n  return isPrimitiveTypeEx(tp);\n}\n\nfunction isPureObject(obj) {\n  return (obj !== undefined\n    && obj !== null\n    && obj.constructor !== Array\n    && typeof obj === 'object');\n}\n\nfunction sanitizePrimitiveValue(value, nullable) {\n  if (nullable) {\n    if (!value) return null;\n    if (!isPrimitiveType(value)) return null;\n    return value;\n  }\n  else {\n    if (!value) return undefined;\n    if (!isPrimitiveType(value)) return undefined;\n    return value;\n  }\n}\n\nfunction checkIfValueDisabled(value, nullable, disabled) {\n  if (disabled) return true;\n  if (value === undefined) return true;\n  if (nullable && value === null) return false;\n  return !isPrimitiveType(value);\n}\n\nconst mathi32_MULTIPLIER = 10000;\n\nconst mathi32_abs = Math.abs;\nconst mathi32_round = Math.round;\nconst mathi32_ceil = Math.ceil;\nconst mathi32_floor = Math.floor;\nconst mathi32_min = Math.min;\nconst mathi32_max = Math.max;\n\nconst mathi32_sqrt = Math.sqrt;\nconst mathi32_asin = Math.asin;\nconst mathi32_atan2 = Math.atan2;\n\nconst mathi32_PI = (Math.PI * mathi32_MULTIPLIER)|0;\nconst mathi32_PI2 = (mathi32_PI * 2)|0;\nconst mathi32_PI1H = (mathi32_PI / 2)|0;\nconst mathi32_PI41 = ((4 / Math.PI) * mathi32_MULTIPLIER)|0;\nconst mathi32_PI42 = ((4 / (Math.PI * Math.PI)) * mathi32_MULTIPLIER)|0;\n\nvar int32Math = {\n  abs: mathi32_abs,\n  round: mathi32_round,\n  floor: mathi32_floor,\n  min: mathi32_min,\n  max: mathi32_max,\n  sqrt: mathi32_sqrt,\n  asin: mathi32_asin,\n  atan2: mathi32_atan2,\n\n  MULTIPLIER: mathi32_MULTIPLIER,\n  PI: mathi32_PI,\n  PI2: mathi32_PI2,\n  PI1H: mathi32_PI1H,\n  PI41: mathi32_PI41,\n  PI42: mathi32_PI42,\n};\n\nconst mathf64_abs = Math.abs;\n\nconst mathf64_sqrt = Math.sqrt;\nconst mathf64_pow = Math.pow;\nconst mathf64_sin = Math.sin;\nconst mathf64_cos = Math.cos;\nconst mathf64_atan2 = Math.atan2;\nconst mathf64_asin = Math.asin;\n\nconst mathf64_ceil = Math.ceil;\nconst mathf64_floor = Math.floor;\nconst mathf64_round = Math.round;\nconst mathf64_min = Math.min;\nconst mathf64_max = Math.max;\n\nconst mathf64_random = Math.random;\n\nconst mathf64_EPSILON = +0.000001;\n\nconst mathf64_SQRTFIVE = +mathf64_sqrt(5);\n\nconst mathf64_PI = +Math.PI;\nconst mathf64_PI2 = +(mathf64_PI * 2);\nconst mathf64_PI1H = +(mathf64_PI / 2);\nconst mathf64_PI41 = +(4 / mathf64_PI);\nconst mathf64_PI42 = +(4 / (mathf64_PI * mathf64_PI));\n\nvar float64Math = {\n  abs: mathf64_abs,\n\n  sqrt: mathf64_sqrt,\n  pow: mathf64_pow,\n  sin: mathf64_sin,\n  cos: mathf64_cos,\n  atan2: mathf64_atan2,\n  asin: mathf64_asin,\n\n  ceil: mathf64_ceil,\n  floor: mathf64_floor,\n  round: mathf64_round,\n  min: mathf64_min,\n  max: mathf64_max,\n\n  random: mathf64_random,\n\n  EPSILON: mathf64_EPSILON,\n\n  SQRTFIVE: mathf64_SQRTFIVE,\n\n  PI: mathf64_PI,\n  PI2: mathf64_PI2,\n  PI1H: mathf64_PI1H,\n  PI41: mathf64_PI41,\n  PI42: mathf64_PI42,\n};\n\nlet random_seed = mathi32_abs(performance.now() ^ (+mathf64_random() * Number.MAX_SAFE_INTEGER));\nfunction int32_random() {\n  const x = (Math.sin(random_seed++) * mathi32_MULTIPLIER);\n  return x - Math.floor(x);\n}\n\nfunction int32_sqrtEx(n = 0) {\n  n = n|0;\n  return (mathi32_MULTIPLIER * mathi32_sqrt(n))|0;\n}\n\nfunction int32_sqrt(n = 0) {\n  n = n|0;\n  return mathi32_sqrt(n)|0;\n}\n\nfunction int32_fib(n = 0) {\n  n = n|0;\n  let c = 0;\n  let x = 1;\n  let i = 1;\n  for (; i !== n; i += 1) {\n    const t = (c + x)|0;\n    c = x|0;\n    x = t|0;\n  }\n  return c|0;\n}\n\nfunction int32_norm(value = 0, min = 0, max = 0) {\n  value = value|0; min = min|0; max = max|0;\n  return ((value - min) / (max - min))|0;\n}\n\nfunction int32_lerp(norm = 0, min = 0, max = 0) {\n  norm = norm|0; min = min|0; max = max|0;\n  return ((max - min) * (norm + min))|0;\n}\n\nfunction int32_map(value = 0, smin = 0, smax = 0, dmin = 0, dmax = 0) {\n  value = value|0; smin = smin|0; smax = smax|0; dmin = dmin|0; dmax = dmax|0;\n  // return int32_lerp(int32_norm(value, smin, smax), dmin, dmax) | 0;\n  return mathi32_round((value - smin) * (dmax - dmin) / (smax - smin) + dmin)|0;\n}\n\nfunction int32_clamp(value = 0, min = 0, max = 0) {\n  value = value|0; min = min|0; max = max|0;\n  return mathi32_min(mathi32_max(value, mathi32_min(min, max)), mathi32_max(min, max))|0;\n}\nfunction int32_clampu(value = 0, min = 0, max = 0) {\n  value = value|0; min = min|0; max = max|0;\n  // return mathi32_min(mathi32_max(value, min), max)|0;\n  return mathi32_max(min, mathi32_min(value, max))|0;\n}\nfunction int32_clampu_u8a(value = 0) {\n  value = value | 0;\n  return -((255 - value & (value - 255) >> 31)\n    - 255 & (255 - value & (value - 255) >> 31)\n    - 255 >> 31);\n}\nfunction int32_clampu_u8b(value = 0) {\n  value = value | 0;\n  value &= -(value >= 0);\n  return value | ~-!(value & -256);\n}\n\nfunction int32_inRange(value = 0, min = 0, max = 0) {\n  value = value|0; min = min|0; max = max|0;\n  return ((value >= mathi32_min(min, max))\n    && (value <= mathi32_max(min, max)))|0;\n}\n\nfunction int32_intersectsRange(smin = 0, smax = 0, dmin = 0, dmax = 0) {\n  smin = smin|0; smax = smax|0; dmin = dmin|0; dmax = dmax|0;\n  return ((mathi32_max(smin, smax) >= mathi32_min(dmin, dmax))\n    && (mathi32_min(smin, smax) <= mathi32_max(dmin, dmax)))|0;\n}\n\nfunction int32_intersectsRect(\n  ax = 0, ay = 0, aw = 0, ah = 0,\n  bx = 0, by = 0, bw = 0, bh = 0,\n) {\n  ax = ax|0; ay = ay|0; aw = aw|0; ah = ah|0; bx = bx|0; by = by|0; bw = bw|0; bh = bh|0;\n  return ((int32_intersectsRange(ax | 0, (ax + aw) | 0, bx | 0, (bx + bw) | 0) > 0)\n    && (int32_intersectsRange(ay|0, (ay + ah)|0, by|0, (by + bh)|0) > 0))|0;\n}\n\nfunction int32_mag2(dx = 0, dy = 0) {\n  dx = dx|0; dy = dy|0;\n  return ((dx * dx) + (dy * dy))|0;\n}\n\nfunction int32_hypot(dx = 0, dy = 0) {\n  dx = dx|0; dy = dy|0;\n  return int32_sqrt((dx * dx) + (dy * dy))|0;\n}\n\nfunction int32_hypotEx(dx = 0, dy = 0) {\n  dx = dx|0; dy = dy|0;\n  return int32_sqrtEx((dx * dx) + (dy * dy))|0;\n}\n\nfunction int32_dot(ax = 0, ay = 0, bx = 0, by = 0) {\n  ax = ax|0; ay = ay|0; bx = bx|0; by = by|0;\n  return ((ax * bx) + (ay * by))|0;\n}\n\nfunction int32_cross(ax = 0, ay = 0, bx = 0, by = 0) {\n  ax = ax|0; ay = ay|0; bx = bx|0; by = by|0;\n  return ((ax * by) - (bx * ay))|0;\n}\n\n//#region trigonometry\n\nfunction int32_toRadianEx(degrees = 0) {\n  degrees = degrees|0;\n  return ((degrees * mathi32_PI) / 180)|0;\n}\n\nfunction int32_toDegreesEx(radians = 0) {\n  radians = radians|0;\n  return ((mathi32_MULTIPLIER * radians * 180) / mathi32_PI)|0;\n}\n\nfunction int32_wrapRadians(r = 0) {\n  r = r|0;\n  if (r > mathi32_PI) return (r - mathi32_PI2)|0;\n  else if (r < -mathi32_PI) return (r + mathi32_PI2)|0;\n  return r|0;\n}\n\nfunction int32_sinLpEx(r = 0) {\n  r = r|0;\n  return ((r < 0)\n    ? (mathi32_PI41 * r + mathi32_PI42 * r * r)\n    : (mathi32_PI41 * r - mathi32_PI42 * r * r))|0;\n}\n\nfunction int32_sinLp(r = 0) {\n  r = r|0;\n  //always wrap input angle between -PI and PI\n  return int32_sinLpEx(int32_wrapRadians(r))|0;\n}\n\nvar int32Base = {\n  random: int32_random,\n  sqrt: int32_sqrt,\n  sqrtEx: int32_sqrtEx,\n  fib: int32_fib,\n  norm: int32_norm,\n  lerp: int32_lerp,\n  map: int32_map,\n  clamp: int32_clamp,\n  clampu: int32_clampu,\n  clamp8u: int32_clampu_u8a,\n  clampu8a: int32_clampu_u8a,\n  clampu8b: int32_clampu_u8b,\n  inRange: int32_inRange,\n  intersectsRange: int32_intersectsRange,\n  intersectsRect: int32_intersectsRect,\n  mag2: int32_mag2,\n  hypot: int32_hypot,\n  hypotEx: int32_hypotEx,\n  dot: int32_dot,\n  cross: int32_cross,\n  toRadianEx: int32_toRadianEx,\n  toDegreesEx: int32_toDegreesEx,\n  wrapRadians: int32_wrapRadians,\n};\n\nclass vec2i32 {\n  constructor(x = 0, y = 0) {\n    this.x = x|0;\n    this.y = y|0;\n  }\n}\n\nconst def_vec2i32 = Object.freeze(Object.seal(new vec2i32()));\n\n//#region flat vec2i pure primitive operators\n\nfunction vec2i32_neg(v = def_vec2i32) {\n  return new vec2i32(\n    (-(v.x|0))|0,\n    (-(v.y|0))|0,\n  );\n}\nfunction vec2i32_add(a = def_vec2i32, b = def_vec2i32) {\n  return new vec2i32(\n    ((a.x|0) + (b.x|0))|0,\n    ((a.y|0) + (b.y|0))|0,\n  );\n}\nfunction vec2i32_adds(v = def_vec2i32, scalar = 0) {\n  scalar = scalar|0;\n  return new vec2i32(\n    ((v.x|0) + scalar)|0,\n    ((v.y|0) + scalar)|0,\n  );\n}\n\nfunction vec2i32_sub(a = def_vec2i32, b = def_vec2i32) {\n  return new vec2i32(\n    ((a.x|0) - (b.x|0))|0,\n    ((a.y|0) - (b.y|0))|0,\n  );\n}\nfunction vec2i32_subs(a = def_vec2i32, scalar = 0) {\n  scalar = scalar|0;\n  return new vec2i32(\n    ((a.x|0) - scalar)|0,\n    ((a.y|0) - scalar)|0,\n  );\n}\n\nfunction vec2i32_mul(a = def_vec2i32, b = def_vec2i32) {\n  return new vec2i32(\n    ((a.x|0) * (b.x|0))|0,\n    ((a.y|0) * (b.y|0))|0,\n  );\n}\nfunction vec2i32_muls(v = def_vec2i32, scalar = 0) {\n  scalar = scalar|0;\n  return new vec2i32(\n    ((v.x|0) * scalar)|0,\n    ((v.y|0) * scalar)|0,\n  );\n}\n\nfunction vec2i32_div(a = def_vec2i32, b = def_vec2i32) {\n  return new vec2i32(\n    ((a.x|0) / (b.x|0))|0,\n    ((a.y|0) / (b.y|0))|0,\n  );\n}\nfunction vec2i32_divs(v = def_vec2i32, scalar = 0) {\n  scalar = scalar|0;\n  return new vec2i32(\n    ((v.x|0) / scalar)|0,\n    ((v.y|0) / scalar)|0,\n  );\n}\n\n\n//#endregion\n\n//#region flat vec2i impure primitive operators\n\nfunction vec2i32_ineg(v = def_vec2i32) {\n  v.x = (-(v.x|0))|0;\n  v.y = (-(v.y|0))|0;\n  return v;\n}\n\nfunction vec2i32_iadd(a = def_vec2i32, b = def_vec2i32) {\n  a.x += (b.x|0)|0;\n  a.y += (b.y|0)|0;\n  return a;\n}\nfunction vec2i32_iadds(v = def_vec2i32, scalar = 0) {\n  scalar = scalar|0;\n  v.x += scalar|0;\n  v.y += scalar|0;\n  return v;\n}\n\nfunction vec2i32_isub(a = def_vec2i32, b = def_vec2i32) {\n  a.x -= (b.x|0)|0;\n  a.y -= (b.y|0)|0;\n  return a;\n}\nfunction vec2i32_isubs(v = def_vec2i32, scalar = 0) {\n  scalar = scalar|0;\n  v.x -= scalar|0;\n  v.y -= scalar|0;\n  return v;\n}\n\nfunction vec2i32_imul(a = def_vec2i32, b = def_vec2i32) {\n  a.x *= (b.x|0)|0;\n  a.y *= (b.y|0)|0;\n  return a;\n}\nfunction vec2i32_imuls(v = def_vec2i32, scalar = 0) {\n  scalar = scalar|0;\n  v.x *= scalar;\n  v.y *= scalar;\n  return v;\n}\n\nfunction vec2i32_idiv(a = def_vec2i32, b = def_vec2i32) {\n  a.x /= b.x|0;\n  a.y /= b.y|0;\n  return a;\n}\nfunction vec2i32_idivs(v = def_vec2i32, scalar = 0) {\n  scalar = scalar|0;\n  v.x /= scalar;\n  v.y /= scalar;\n  return v;\n}\n\n//#endregion\n\n//#region flat vec2i vector products\n\nfunction vec2i32_mag2(v = def_vec2i32) {\n  return (((v.x|0) * (v.x|0)) + ((v.y|0) * (v.y|0)))|0;\n}\nfunction vec2i32_mag(v = def_vec2i32) {\n  return mathi32_sqrt(+vec2i32_mag2(v))|0;\n}\n\nfunction vec2i32_dot(a = def_vec2i32, b = def_vec2i32) {\n  return (((a.x|0) * (b.x|0)) + ((a.y|0) * (b.y|0)))|0;\n}\nfunction vec2i32_cross(a = def_vec2i32, b = def_vec2i32) {\n  return (((a.x|0) * (b.y|0)) - ((a.y|0) * (b.x|0)))|0;\n}\n\nfunction vec2i32_cross3(a = def_vec2i32, b = def_vec2i32, c = def_vec2i32) {\n  return ((((b.x | 0) - (a.x | 0)) * ((c.y | 0) - (a.y | 0)))\n    - (((b.y|0) - (a.y|0)) * ((c.x|0) - (a.x|0))));\n}\n\nfunction vec2i32_thetaEx(v = def_vec2i32) {\n  return (mathi32_MULTIPLIER * mathi32_atan2((v.y|0), (v.x|0)))|0;\n}\nconst vec2i32_angleEx = vec2i32_thetaEx;\n\nfunction vec2i32_phiEx(v= def_vec2i32) {\n  return (mathi32_MULTIPLIER * mathi32_asin((v.y|0) / vec2i32_mag(v)));\n}\n\n\n//#endregion\n\n//#region flat vec2i pure advanced vector functions\n\nfunction vec2i32_norm(v = def_vec2i32) {\n  return vec2i32_divs(v, vec2i32_mag(v)|0)|0;\n}\n\nfunction vec2i32_rotn90(v = def_vec2i32) {\n  return new vec2i32(\n    v.y|0,\n    (-(v.x|0))|0,\n  );\n}\nfunction vec2i32_rot90(v = def_vec2i32) {\n  return {\n    x: (-(v.y|0))|0,\n    y: v.x|0,\n  };\n}\nconst vec2i32_perp = vec2i32_rot90;\n\n\n//#endregion\n\n//#region rotation\nfunction vec2i32_inorm(v = def_vec2i32) {\n  return vec2i32_idivs(v, vec2i32_mag(v)|0)|0;\n}\n\nfunction vec2i32_irotn90(v = def_vec2i32) {\n  const t = v.x|0;\n  v.x = v.y|0;\n  v.y = (-(t))|0;\n  return v;\n}\n\nfunction vec2i32_irot90(v = def_vec2i32) {\n  const t = v.y|0;\n  v.x = (-(t))|0;\n  v.y = (v.x|0);\n  return v;\n}\nconst vec2i32_iperp = vec2i32_irot90;\n\n//#endregion\n\n//#region shapes\n\n/**\n * Tests if triangle intersects with a rectangle\n *\n * @param {*} v1\n * @param {*} v2\n * @param {*} v3\n * @param {*} r1\n * @param {*} r2\n * @returns {boolean} true if they intersect.\n */\nfunction triangle2i_intersectsRect(v1, v2, v3, r1, r2) {\n  /*\n    This function borrowed faithfully from a wonderfl (:3) discussion on\n    calculating triangle collision with AABBs on the following blog:\n    http://sebleedelisle.com/2009/05/super-fast-trianglerectangle-intersection-test/\n\n    This particular optimization best suits my purposes and was contributed\n    to the discussion by someone from http://lab9.fr/\n  */\n\n  const x0 = v1.x|0;\n  const y0 = v1.y|0;\n  const x1 = v2.x|0;\n  const y1 = v2.y|0;\n  const x2 = v3.x|0;\n  const y2 = v3.y|0;\n\n  const l = r1.x|0;\n  const r = r2.x|0;\n  const t = r1.y|0;\n  const b = r2.y|0;\n\n  const b0 = (((x0 > l) ? 1 : 0)\n    | (((y0 > t) ? 1 : 0) << 1)\n    | (((x0 > r) ? 1 : 0) << 2)\n    | (((y0 > b) ? 1 : 0) << 3))|0;\n  if (b0 === 3) return true;\n\n  const b1 = ((x1 > l) ? 1 : 0)\n    | (((y1 > t) ? 1 : 0) << 1)\n    | (((x1 > r) ? 1 : 0) << 2)\n    | (((y1 > b) ? 1 : 0) << 3)|0;\n  if (b1 === 3) return true;\n\n  const b2 = ((x2 > l) ? 1 : 0)\n    | (((y2 > t) ? 1 : 0) << 1)\n    | (((x2 > r) ? 1 : 0) << 2)\n    | (((y2 > b) ? 1 : 0) << 3)|0;\n  if (b2 === 3) return true;\n\n  let c = 0;\n  let m = 0;\n  let s = 0;\n\n  const i0 = (b0 ^ b1)|0;\n  if (i0 !== 0) {\n    m = ((y1-y0) / (x1-x0))|0;\n    c = (y0 -(m * x0))|0;\n    if (i0 & 1) {\n      s = m * l + c;\n      if (s > t && s < b) return true;\n    }\n    if (i0 & 2) {\n      s = (t - c) / m;\n      if (s > l && s < r) return true;\n    }\n    if (i0 & 4) {\n      s = m * r + c;\n      if (s > t && s < b) return true;\n    }\n    if (i0 & 8) {\n      s = (b - c) / m;\n      if (s > l && s < r) return true;\n    }\n  }\n\n  const i1 = (b1 ^ b2)|0;\n  if (i1 !== 0) {\n    m = ((y2 - y1) / (x2 - x1))|0;\n    c = (y1 -(m * x1))|0;\n    if (i1 & 1) {\n      s = m * l + c;\n      if (s > t && s < b) return true;\n    }\n    if (i1 & 2) {\n      s = (t - c) / m;\n      if (s > l && s < r) return true;\n    }\n    if (i1 & 4) {\n      s = m * r + c;\n      if (s > t && s < b) return true;\n    }\n    if (i1 & 8) {\n      s = (b - c) / m;\n      if (s > l && s < r) return true;\n    }\n  }\n\n  const i2 = (b0 ^ b2)|0;\n  if (i2 !== 0) {\n    m = ((y2 - y0) / (x2 - x0))|0;\n    c = (y0 -(m * x0))|0;\n    if (i2 & 1) {\n      s = m * l + c;\n      if (s > t && s < b) return true;\n    }\n    if (i2 & 2) {\n      s = (t - c) / m;\n      if (s > l && s < r) return true;\n    }\n    if (i2 & 4) {\n      s = m * r + c;\n      if (s > t && s < b) return true;\n    }\n    if (i2 & 8) {\n      s = (b - c) / m;\n      if (s > l && s < r) return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * just some notes\n *\n *\nconst fastSin_B = 1.2732395; // 4/pi\nconst fastSin_C = -0.40528473; // -4 / (pi²)\nexport function fastSin(value) {\n  // See  for graph and equations\n  // https://www.desmos.com/calculator/8nkxlrmp7a\n  // logic explained here : http://devmaster.net/posts/9648/fast-and-accurate-sine-cosine\n\n  return (value > 0)\n    ? fastSin_B * value - fastSin_C * value * value\n    : fastSin_B * value + fastSin_C * value * value;\n}\n\nexport function fastSin2(a) {\n  let b, c;\n  return a *= 5214\n    , c = a << 17\n    , a -= 8192\n    , a <<= 18\n    , a >>= 18\n    , a = a * a >> 12\n    , b = 19900 - (3516 * a >> 14)\n    , b = 4096 - (a * b >> 16)\n    , 0 > c && (b = -b)\n    , 2.44E-4 * b;\n};\n\nexport function fastSin3(a) {\n  a *= 5214;\n  let b = a << 17;\n  a = a - 8192 << 18 >> 18;\n  a = a * a >> 12;\n  a = 4096 - (a * (19900 - (3516 * a >> 14)) >> 16);\n  0 > b && (a = -a);\n  return 2.44E-4 * a\n};\n\n\n */\n\nvar int32Vec2 = {\n  vec2: vec2i32,\n  default: def_vec2i32,\n\n  neg: vec2i32_neg,\n  add: vec2i32_add,\n  adds: vec2i32_adds,\n  sub: vec2i32_sub,\n  subs: vec2i32_subs,\n  mul: vec2i32_mul,\n  muls: vec2i32_muls,\n  div: vec2i32_div,\n  divs: vec2i32_divs,\n\n  ineg: vec2i32_ineg,\n  iadd: vec2i32_iadd,\n  iadds: vec2i32_iadds,\n  isub: vec2i32_isub,\n  isubs: vec2i32_isubs,\n  imul: vec2i32_imul,\n  imuls: vec2i32_imuls,\n  idiv: vec2i32_idiv,\n  idivs: vec2i32_idivs,\n\n  mag2: vec2i32_mag2,\n  mag: vec2i32_mag,\n  dot: vec2i32_dot,\n  cross: vec2i32_cross,\n  cross3: vec2i32_cross3,\n  thetaEx: vec2i32_thetaEx,\n  angleEx: vec2i32_thetaEx,\n  phiEx: vec2i32_phiEx,\n  norm: vec2i32_norm,\n  rotn90: vec2i32_rotn90,\n  rot90: vec2i32_rot90,\n  perp: vec2i32_rot90,\n\n  inorm: vec2i32_inorm,\n  irotn90: vec2i32_irotn90,\n  irot90: vec2i32_irot90,\n  iperp: vec2i32_iperp,\n};\n\nfunction float64_gcd(a=0.0, b=0.0) {\n  a = +a; b = +b;\n  // For example, a 1024x768 monitor has a GCD of 256.\n  // When you divide both values by that you get 4x3 or 4: 3.\n  return +((b === 0.0) ? +a : +float64_gcd(b, a % b));\n}\n\nfunction float64_sqrt(n = 0.0) {\n  return +mathf64_sqrt(+n);\n}\n\nfunction float64_hypot2(dx = 0.0, dy = 0.0) {\n  return +(+(+dx * +dx) + +(+dy * +dy));\n}\n\nfunction float64_hypot(dx = 0.0, dy = 0.0) {\n  return +mathf64_sqrt(+(+(+dx * +dx) + +(+dy * +dy)));\n}\n\nconst float64_isqrt = (function float64_isqrt_oncompile() {\n  const f = new Float32Array(1);\n  const i = new Int32Array(f.buffer);\n  return function float64_isqrt_impl(n = 0.0) {\n    n = +n;\n    const n2 = +(n * 0.5);\n    f[0] = +n;\n    i[0] = (0x5f375a86 - ((i[0]|0) >> 1))|0;\n    n = +f[0];\n    return +(+n * +(1.5 - (+n2 * +n * +n)));\n  };\n})();\n\nfunction float64_fib(n = 0.0) {\n  n = +n;\n  let c = 0.0;\n  let x = 1.0;\n  let i = 1.0;\n  for (; i !== n; i += 1.0) {\n    const t = +(+c + +x);\n    c = +x;\n    x = +t;\n  }\n  return +c;\n}\n\n// https://gist.github.com/geraldyeo/988116export\nfunction float64_fib2(value = 0.0) {\n  value = +value;\n  const fh = +(1.0 / +mathf64_SQRTFIVE * +mathf64_pow(+(+(1.0 + mathf64_SQRTFIVE) / 2.0), +value));\n  const sh = +(1.0 / +mathf64_SQRTFIVE * +mathf64_pow(+(+(1.0 - mathf64_SQRTFIVE) / 2.0), +value));\n  return +mathf64_round(+(fh - sh));\n}\n\nfunction float64_norm(value = 0.0, min = 0.0, max = 0.0) {\n  value = +value; min = +min; max = +max;\n  return +((value - min) / (max - min));\n}\n\nfunction float64_lerp(norm = 0.0, min = 0.0, max = 0.0) {\n  norm = +norm; min = +min; max = +max;\n  return +((max - min) * (norm + min));\n}\n\nfunction float64_map(value = 0.0, smin = 0.0, smax = 0.0, dmin = 0.0, dmax = 0.0) {\n  value = +value; smin = +smin; smax = +smax; dmin = +dmin; dmax = +dmax;\n  return +float64_lerp(+float64_norm(value, smin, smax), dmin, dmax);\n}\n\n/**\n * Clamps a value between a checked boudary.\n * and can therefor handle swapped min/max arguments\n *\n * @param {float} value input value\n * @param {float} min minimum bounds\n * @param {float} max maximum bounds\n * @returns {float} clamped value\n */\nfunction float64_clamp(value = 0.0, min = 0.0, max = 0.0) {\n  return +mathf64_min(+mathf64_max(+value, +mathf64_min(+min, +max)), +mathf64_max(+min, +max));\n}\n/**\n * Clamps a value between an unchecked boundary\n * this function needs min < max!!\n * (see float64_clamp for a checked boundary)\n *\n * @param {float} value input value\n * @param {float} min minimum bounds\n * @param {float} max maximum bounds\n * @returns {float} clamped value\n */\nfunction float64_clampu(value = 0.0, min = 0.0, max = 0.0) {\n  return +mathf64_min(+mathf64_max(+value, +min), +max);\n}\n\nfunction float64_inRange(value = 0.0, min = 0.0, max = 0.0) {\n  return +(+value >= +mathf64_min(+min, +max) && +value <= +mathf64_max(+min, +max));\n}\n\nfunction float64_intersectsRange(smin = 0.0, smax = 0.0, dmin = 0.0, dmax = 0.0) {\n  return +(+mathf64_max(+smin, +smax) >= +mathf64_min(+dmin, +dmax)\n    && +mathf64_min(+smin, +smax) <= +mathf64_max(+dmin, +dmax));\n}\n\nfunction float64_intersectsRect(\n  ax = 0.0, ay = 0.0, aw = 0.0, ah = 0.0,\n  bx = 0.0, by = 0.0, bw = 0.0, bh = 0.0,\n) {\n  return +(+(+float64_intersectsRange(+ax, +(+ax + +aw), +bx, +(+bx + +bw)) > 0.0\n    && +float64_intersectsRange(+ay, +(+ay + +ah), +by, +(+by + +bh)) > 0.0));\n}\n\n/**\n *\n * We can calculate the Dot Product of two vectors this way:\n *\n *    a · b = |a| × |b| × cos(θ)\n *\n * or in this implementation as:\n *\n *    a · b = ax × bx + ay × by\n *\n * When two vectors are at right angles to each other the dot product is zero.\n *\n * @param {float} ax vector A x velocity\n * @param {float} ay vector A y velocity\n * @param {float} bx vector B x velocity\n * @param {float} by vector B y velocity\n * @returns {float} scalar of the dot product\n */\nfunction float64_dot(ax = 0.0, ay = 0.0, bx = 0.0, by = 0.0) {\n  return +(+(+ax * +bx) + +(+ay * +by));\n}\n\n/**\n *\n * The Cross Product Magnitude\n * a × b of two vectors is another vector that is at right angles to both:\n * The magnitude (length) of the cross product equals the area\n * of a parallelogram with vectors a and b for sides:\n *\n * We can calculate the Cross Product this way:\n *\n *    a × b = |a| |b| sin(θ) n\n *\n * or as\n *\n *    a × b = ax × by - bx × ay\n *\n * Another useful property of the cross product is,\n * that its magnitude is related to the sine of\n * the angle between the two vectors:\n *\n *    | a x b | = |a| . |b| . sine(theta)\n *\n * or\n *\n *    sine(theta) = | a x b | / (|a| . |b|)\n *\n * So, in implementation 1 above, if a and b are known in advance\n * to be unit vectors then the result of that function is exactly that sine() value.\n * @param {float} ax\n * @param {float} ay\n * @param {float} bx\n * @param {float} by\n */\nfunction float64_cross(ax = 0.0, ay = 0.0, bx = 0.0, by = 0.0) {\n  return +(+(+ax * +by) - +(+bx * +ay));\n}\n\n//#region trigonometry\n\nfunction float64_toRadian(degrees = 0.0) {\n  return +(+degrees * +Math.PI / 180.0);\n}\n\nfunction float64_toDegrees(radians = 0.0) {\n  return +(+radians * 180.0 / +Math.PI);\n}\n\nfunction float64_wrapRadians(r = 0.0) {\n  r = +r;\n  if (+r > Math.PI) return +(+r - +mathf64_PI2);\n  else if (+r < -Math.PI) return +(+r + +mathf64_PI2);\n  return +r;\n}\n\nfunction float64_sinLpEx(r = 0.0) {\n  r = +r;\n  return +((r < 0.0)\n    ? +(+mathf64_PI41 * +r + +mathf64_PI42 * +r * +r)\n    : +(+mathf64_PI41 * +r - +mathf64_PI42 * +r * +r));\n}\n\nfunction float64_sinLp(r = 0.0) {\n  //always wrap input angle between -PI and PI\n  return +float64_sinLpEx(+float64_wrapRadians(+r));\n}\n\nfunction float64_cosLp(r = 0.0) {\n  //compute cosine: sin(x + PI/2) = cos(x)\n  return +float64_sinLp(+(+r + +mathf64_PI1H));\n}\n\nfunction float64_cosHp(r = 0.0) {\n//   template<typename T>\n// inline T cos(T x) noexcept\n// {\n//     constexpr T tp = 1./(2.*M_PI);\n//     x *= tp;\n//     x -= T(.25) + std::floor(x + T(.25));\n//     x *= T(16.) * (std::abs(x) - T(.5));\n//     #if EXTRA_PRECISION\n//     x += T(.225) * x * (std::abs(x) - T(1.));\n//     #endif\n//     return x;\n// }\n  throw new Error('float64_cosHp is not implemented! r=' + String(r));\n}\n\nfunction float64_sinMpEx(r = 0.0) {\n  r = +r;\n  const sin = +((r < 0.0)\n    ? +(mathf64_PI41 * r + mathf64_PI42 * r * r)\n    : +(mathf64_PI41 * r - mathf64_PI42 * r * r));\n  return +((sin < 0.0)\n    ? +(0.225 * (sin * -sin - sin) + sin)\n    : +(0.225 * (sin * sin - sin) + sin));\n}\n\nfunction float64_sinMp(r = 0.0) {\n  return +float64_sinMpEx(+float64_wrapRadians(+r));\n}\nfunction float64_cosMp(r = 0.0) {\n  //compute cosine: sin(x + PI/2) = cos(x)\n  return +float64_sinMp(+(+r + +mathf64_PI1H));\n}\n\nfunction float64_theta(x = 0.0, y = 0.0) {\n  return +mathf64_atan2(+y, +x);\n  /*\n    // alternative was faster, but not anymore.\n    // error < 0.005\n    y = +y;\n    x = +x;\n    if (x == 0.0) {\n      if (y > 0.0) return +(Math.PI / 2.0);\n      if (y == 0.0) return 0.0;\n      return +(-Math.PI / 2.0);\n    }\n\n    const z = +(y / x);\n    var atan = 0.0;\n    if (+Math.abs(z) < 1.0) {\n      atan = +(z / (1.0 + 0.28 * z * z));\n      if (x < 0.0) {\n        if (y < 0.0) return +(atan - Math.PI);\n        return +(atan + Math.PI);\n      }\n    }\n    else {\n      atan = +(Math.PI / 2.0 - z / (z * z + 0.28));\n      if (y < 0.0) return +(atan - Math.PI);\n    }\n    return +(atan);\n  */\n}\n\nfunction float64_phi(y = 0.0, length = 0.0) {\n  return +mathf64_asin(+y / +length);\n}\n\n//#endregion\n\nvar float64Base = {\n  gcd: float64_gcd,\n  sqrt: float64_sqrt,\n  hypot2: float64_hypot2,\n  hypot: float64_hypot,\n  isqrt: float64_isqrt,\n  fib: float64_fib,\n  fib2: float64_fib2,\n  norm: float64_norm,\n  lerp: float64_lerp,\n\n  map: float64_map,\n  clamp: float64_clamp,\n  clampu: float64_clampu,\n\n  inrange: float64_inRange,\n  intersectsRange: float64_intersectsRange,\n  intersectsRect: float64_intersectsRect,\n\n  dot: float64_dot,\n  cross: float64_cross,\n\n  toRadian: float64_toRadian,\n  toDefrees: float64_toDegrees,\n  wrapRadians: float64_wrapRadians,\n\n  theta: float64_theta,\n  phi: float64_phi,\n};\n\n/* eslint-disable one-var-declaration-per-line */\n\nclass vec2f64 {\n  constructor(x = 0.0, y = 0.0) {\n    this.x = +x;\n    this.y = +y;\n  }\n}\n\n//#region -- object oriented implementation --\n\n//#region class pure primitive vector operators\n\nvec2f64.prototype.neg = function _vec2f64__neg() {\n  return new vec2f64(+(-(+this.x)), +(-(+this.y)));\n};\n\nvec2f64.prototype.add = function _vec2f64__add(vector = def_vec2f64) {\n  return new vec2f64(+(+this.x + +vector.x), +(+this.y + +vector.y));\n};\nvec2f64.prototype.adds = function _vec2f64__adds(scalar = 0.0) {\n  return new vec2f64(+(+this.x + +scalar), +(+this.y + +scalar));\n};\n\nvec2f64.prototype.sub = function _vec2f64__sub(vector = def_vec2f64) {\n  return new vec2f64(+(+this.x - +vector.x), +(+this.y - +vector.y));\n};\nvec2f64.prototype.subs = function _vec2f64__subs(scalar = 0.0) {\n  return new vec2f64(+(+this.x - +scalar), +(+this.y - +scalar));\n};\n\nvec2f64.prototype.mul = function _vec2f64__mul(vector = def_vec2f64) {\n  return new vec2f64(+(+this.x * +vector.x), +(+this.y * +vector.y));\n};\nvec2f64.prototype.muls = function _vec2f64__muls(scalar = 0.0) {\n  return new vec2f64(+(+this.x * +scalar), +(+this.y * +scalar));\n};\n\nvec2f64.prototype.div = function _vec2f64__div(vector = def_vec2f64) {\n  return new vec2f64(+(+this.x / +vector.x), +(+this.y / +vector.y));\n};\nvec2f64.prototype.divs = function _vec2f64__divs(scalar = 0.0) {\n  return new vec2f64(+(+this.x / +scalar), +(+this.y / +scalar));\n};\n\n//#endregion\n\n//#region class impure primitive vector operators\nvec2f64.prototype.ineg = function _vec2f64__ineg() {\n  this.x = +(-(+this.x));\n  this.y = +(-(+this.y));\n  return this;\n};\n\nvec2f64.prototype.iadd = function _vec2f64__iadd(vector = def_vec2f64) {\n  this.x += +vector.x;\n  this.y += +vector.y;\n  return this;\n};\nvec2f64.prototype.iadds = function _vec2f64__iadds(value = 0.0) {\n  this.x += +value;\n  this.y += +value;\n  return this;\n};\n\nvec2f64.prototype.isub = function _vec2f64__isub(vector = def_vec2f64) {\n  this.x -= +vector.x;\n  this.y -= +vector.y;\n  return this;\n};\nvec2f64.prototype.isubs = function _vec2f64__isubs(value = 0.0) {\n  this.x -= +value;\n  this.y -= +value;\n  return this;\n};\n\nvec2f64.prototype.imul = function _vec2f64__imul(vector = def_vec2f64) {\n  this.x *= +vector.x;\n  this.y *= +vector.y;\n  return this;\n};\nvec2f64.prototype.imuls = function _vec2f64__imuls(value = 0.0) {\n  this.x *= +value;\n  this.y *= +value;\n  return this;\n};\n\nvec2f64.prototype.idiv = function _vec2f64__idiv(vector = def_vec2f64) {\n  this.x /= +vector.x;\n  this.y /= +vector.y;\n  return this;\n};\nvec2f64.prototype.idivs = function _vec2f64__idivs(value = 0.0) {\n  this.x /= +value;\n  this.y /= +value;\n  return this;\n};\n\n//#endregion\n\n//#region class vector products\nvec2f64.prototype.mag2 = function _vec2f64__mag2() {\n  return +(+(+this.x * +this.x) + +(+this.y * +this.y));\n};\nvec2f64.prototype.mag = function _vec2f64__mag() {\n  return +mathf64_sqrt(+this.mag2());\n};\n\nvec2f64.prototype.dot = function _vec2f64__dot(vector = def_vec2f64) {\n  return +(+(+this.x * +vector.x) + +(+this.y * +vector.y));\n};\n\n/**\n * Returns the cross-product of two vectors\n *\n * @param {vec2f64} vector B\n * @returns {double} The cross product of two vectors\n */\nvec2f64.prototype.cross = function _vec2f64__cross(vector = def_vec2f64) {\n  return +(+(+this.x * +vector.y) - +(+this.y * +vector.x));\n};\n\n/**\n * Returns the cross-product of three vectors\n *\n * You can determine which side of a line a point is on\n * by converting the line to hyperplane form (implicitly\n * or explicitly) and then computing the perpendicular\n * (pseudo)distance from the point to the hyperplane.\n *\n * With the crossproduct of two vectors A and B being the vector\n *\n * AxB = (AyBz − AzBy, AzBx − AxBz, AxBy − AyBx)\n * with Az and Bz being zero you are left with the third component of that vector\n *\n *    AxBy - AyBx\n *\n * With A being the vector from point a to b, and B being the vector from point a to c means\n *\n *    Ax = (b[x]-a[x])\n *    Ay = (b[y]-a[y])\n *    Bx = (c[x]-a[x])\n *    By = (c[y]-a[y])\n *\n * giving\n *\n *    AxBy - AyBx = (b[x]-a[x])*(c[y]-a[y])-(b[y]-a[y])*(c[x]-a[x])\n *\n * which is a scalar, the sign of that scalar will tell you wether point c\n * lies to the left or right of vector ab\n *\n * @param {vec2f64} vector B\n * @param {vec2f64} vector C\n * @returns {double} The cross product of three vectors\n *\n */\nvec2f64.prototype.cross3 = function _vec2f64__cross3(vector2 = def_vec2f64, vector3 = def_vec2f64) {\n  return +(\n    +(+(+vector2.x - +this.x) * +(+vector3.y - +this.y))\n    - +(+(+vector2.y - +this.y) * +(+vector3.x - +this.x)));\n};\n\n/**\n * Returns the angle in radians of its vector\n *\n * Math.atan2(dy, dx) === Math.asin(dy/Math.sqrt(dx*dx + dy*dy))\n *\n * @param {} v Vector\n */\nfunction _vec2f64__theta() {\n  return +mathf64_atan2(+this.y, +this.x);\n}\nvec2f64.prototype.theta = _vec2f64__theta;\nvec2f64.prototype.angle = _vec2f64__theta;\nvec2f64.prototype.phi = function _vec2__phi() {\n  return +mathf64_asin(+this.y / +this.mag());\n};\n\n//#endregion\n\n//#region class pure advanced vector functions\nvec2f64.prototype.unit = function _vec2f64__unit() {\n  return this.divs(+this.mag());\n};\n\nvec2f64.prototype.rotn90 = function _vec2f64__rotn90() {\n  return new vec2f64(+this.y, +(-(+this.x)));\n};\nfunction _vec2f64__rot90() {\n  return new vec2f64(+(-(+this.y)), +this.x);\n}\nvec2f64.prototype.rot90 = _vec2f64__rot90;\nvec2f64.prototype.perp = _vec2f64__rot90;\n\n/**\n * Rotates a vector by the specified angle in radians\n *\n * @param {float} r  angle in radians\n * @returns {vec2f64} transformed output vector\n */\nvec2f64.prototype.rotate = function _vec2f64__rotate(radians = 0.0) {\n  return new vec2f64(\n    +(+(+this.x * +mathf64_cos(+radians)) - +(+this.y * +mathf64_sin(+radians))),\n    +(+(+this.x * +mathf64_sin(+radians)) + +(+this.y * +mathf64_cos(+radians))),\n  );\n};\nvec2f64.prototype.about = function _vec2f64__about(vector = def_vec2f64, radians = 0.0) {\n  return new vec2f64(\n    +(+vector.x + +(+(+(+this.x - +vector.x) * +mathf64_cos(+radians))\n      - +(+(+this.y - +vector.y) * +mathf64_sin(+radians)))),\n    +(+vector.y + +(+(+(+this.x - +vector.x) * +mathf64_sin(+radians))\n      + +(+(+this.y - +vector.y) * +mathf64_cos(+radians)))),\n  );\n};\n\n//#endregion\n\n//#region class impure advanced vector functions\nvec2f64.prototype.iunit = function _vec2f64__iunit() {\n  return this.idivs(+this.mag());\n};\n\nvec2f64.prototype.irotn90 = function _vec2f64__irotn90() {\n  this.x = +this.y;\n  this.y = +(-(+this.x));\n  return this;\n};\nfunction _vec2f64__irot90() {\n  this.x = +(-(+this.y));\n  this.y = +this.x;\n  return this;\n}\nvec2f64.prototype.irot90 = _vec2f64__irot90;\nvec2f64.prototype.iperp = _vec2f64__irot90;\n\nvec2f64.prototype.irotate = function _vec2f64__irotate(radians = 0.0) {\n  this.x = +(+(+this.x * +mathf64_cos(+radians)) - +(+this.y * +mathf64_sin(+radians)));\n  this.y = +(+(+this.x * +mathf64_sin(+radians)) + +(+this.y * +mathf64_cos(+radians)));\n  return this;\n};\nvec2f64.prototype.iabout = function _vec2f64__iabout(vector = def_vec2f64, radians = 0.0) {\n  this.x = +(+vector.x + +(+(+(+this.x - +vector.x) * +mathf64_cos(+radians))\n    - +(+(+this.y - +vector.y) * +mathf64_sin(+radians))));\n  this.y = +(+vector.y + +(+(+(+this.x - +vector.x) * +mathf64_sin(+radians))\n    + +(+(+this.y - +vector.y) * +mathf64_cos(+radians))));\n  return this;\n};\n\n//#endregion\n\n//#endregion\n\n//#region -- functional implementation --\n\n//#region flat vec2f pure primitive operators\n\nfunction vec2f64_neg(v = def_vec2f64) {\n  return new vec2f64(\n    +(-(+v.x)),\n    +(-(+v.y)),\n  );\n}\nfunction vec2f64_add(a = def_vec2f64, b = def_vec2f64) {\n  return new vec2f64(\n    +(+a.x + +b.x),\n    +(+a.y + +b.y),\n  );\n}\nfunction vec2f64_adds(v = def_vec2f64, scalar = 0.0) {\n  return new vec2f64(\n    +(+v.x + +scalar),\n    +(+v.y + +scalar),\n  );\n}\nfunction vec2f64_addms(a = def_vec2f64, b = def_vec2f64, scalar = 1.0) {\n  return new vec2f64(\n    +(+a.x + +(+b.x * +scalar)),\n    +(+a.y + +(+b.y * +scalar)),\n  );\n}\n\nfunction vec2f64_sub(a = def_vec2f64, b = def_vec2f64) {\n  return new vec2f64(\n    +(+a.x - +b.x),\n    +(+a.y - +b.y),\n  );\n}\nfunction vec2f64_subs(a = def_vec2f64, scalar = 0.0) {\n  return new vec2f64(\n    +(+a.x - +scalar),\n    +(+a.y - +scalar),\n  );\n}\n\nfunction vec2f64_mul(a = def_vec2f64, b = def_vec2f64) {\n  return new vec2f64(\n    +(+a.x * +b.x),\n    +(+a.y * +b.y),\n  );\n}\nfunction vec2f64_muls(v = def_vec2f64, scalar = 1.0) {\n  return new vec2f64(\n    +(+v.x * +scalar),\n    +(+v.y * +scalar),\n  );\n}\n\nfunction vec2f64_div(a = def_vec2f64, b = def_vec2f64) {\n  return new vec2f64(\n    +(+a.x / +b.x),\n    +(+a.y / +b.y),\n  );\n}\nfunction vec2f64_divs(v = def_vec2f64, scalar = 1.0) {\n  return new vec2f64(\n    +(+v.x / +scalar),\n    +(+v.y / +scalar),\n  );\n}\nfunction vec2f64_inv(v = def_vec2f64) {\n  return new vec2f64(\n    1.0 / +v.x,\n    1.0 / +v.y,\n  );\n}\n\nfunction vec2f64_ceil(v = def_vec2f64) {\n  return new vec2f64(\n    +mathf64_ceil(+v.x),\n    +mathf64_ceil(+v.y),\n  );\n}\nfunction vec2f64_floor(v = def_vec2f64) {\n  return new vec2f64(\n    +mathf64_floor(+v.x),\n    +mathf64_floor(+v.y),\n  );\n}\nfunction vec2f64_round(v = def_vec2f64) {\n  return new vec2f64(\n    +mathf64_round(+v.x),\n    +mathf64_round(+v.y),\n  );\n}\n\nfunction vec2f64_min(a = def_vec2f64, b = def_vec2f64) {\n  return new vec2f64(\n    +mathf64_min(+a.x, +b.x),\n    +mathf64_min(+a.y, +b.y),\n  );\n}\nfunction vec2f64_max(a = def_vec2f64, b = def_vec2f64) {\n  return new vec2f64(\n    +mathf64_max(+a.x, +b.x),\n    +mathf64_max(+a.y, +b.y),\n  );\n}\n\n//#endregion\n\n//#region flat vec2f impure primitive operators\nfunction vec2f64_ineg(v = def_vec2f64) {\n  v.x = +(-(+v.x));\n  v.y = +(-(+v.y));\n  return v;\n}\nfunction vec2f64_iadd(a = def_vec2f64, b = def_vec2f64) {\n  a.x += +b.x;\n  a.y += +b.y;\n  return a;\n}\nfunction vec2f64_iadds(v = def_vec2f64, scalar = 0.0) {\n  v.x += +scalar;\n  v.y += +scalar;\n  return v;\n}\nfunction vec2f64_iaddms(a = def_vec2f64, b = def_vec2f64, scalar = 1.0) {\n  a.x = +(+a.x + +(+b.x * +scalar));\n  a.y = +(+a.y + +(+b.y * +scalar));\n  return a;\n}\nfunction vec2f64_isub(a = def_vec2f64, b = def_vec2f64) {\n  a.x -= +(+b.x);\n  a.y -= +(+b.y);\n  return a;\n}\nfunction vec2f64_isubs(v = def_vec2f64, scalar = 0.0) {\n  v.x -= +scalar;\n  v.y -= +scalar;\n  return v;\n}\n\nfunction vec2f64_imul(a = def_vec2f64, b = def_vec2f64) {\n  a.x *= +(+b.x);\n  a.y *= +(+b.y);\n  return a;\n}\nfunction vec2f64_imuls(v = def_vec2f64, scalar = 1.0) {\n  v.x *= +scalar;\n  v.y *= +scalar;\n  return v;\n}\n\nfunction vec2f64_idiv(a = def_vec2f64, b = def_vec2f64) {\n  a.x /= +(+b.x);\n  a.y /= +(+b.y);\n  return a;\n}\nfunction vec2f64_idivs(v = def_vec2f64, scalar = 1.0) {\n  v.x /= +scalar;\n  v.y /= +scalar;\n  return v;\n}\nfunction vec2f64_iinv(v = def_vec2f64) {\n  v.x = 1.0 / +v.x;\n  v.y = 1.0 / +v.y;\n  return v;\n}\n\nfunction vec2f64_iceil(v = def_vec2f64) {\n  v.x = +mathf64_ceil(+v.x);\n  v.y = +mathf64_ceil(+v.y);\n  return v;\n}\nfunction vec2f64_ifloor(v = def_vec2f64) {\n  v.x = +mathf64_floor(+v.x);\n  v.y = +mathf64_floor(+v.y);\n  return v;\n}\nfunction vec2f64_iround(v = def_vec2f64) {\n  v.x = +mathf64_round(+v.x);\n  v.y = +mathf64_round(+v.y);\n  return v;\n}\n\nfunction vec2f64_imin(a = def_vec2f64, b = def_vec2f64) {\n  a.x = +mathf64_min(+a.x, +b.x);\n  a.y = +mathf64_min(+a.y, +b.y);\n  return a;\n}\nfunction vec2f64_imax(a = def_vec2f64, b = def_vec2f64) {\n  a.x = +mathf64_max(+a.x, +b.x);\n  a.y = +mathf64_max(+a.y, +b.y);\n  return a;\n}\n\n//#endregion\n\n//#region flat vec2f boolean products\nfunction vec2f64_eqstrict(a = def_vec2f64, b = def_vec2f64) {\n  return a.x === b.x && a.y === b.y;\n}\nconst vec2f64_eqs = vec2f64_eqstrict;\nfunction vec2f64_eq(a = def_vec2f64, b = def_vec2f64) {\n  const ax = +a.x, ay = +a.y, bx = +b.x, by = +b.y;\n  return (mathf64_abs(ax - bx)\n    <= mathf64_EPSILON * mathf64_max(1.0, mathf64_abs(ax), mathf64_abs(bx))\n    && mathf64_abs(ay - by)\n    <= mathf64_EPSILON * mathf64_max(1.0, mathf64_abs(ay), mathf64_abs(by))\n  );\n}\n\n//#endregion\n\n//#region flat vec2f vector products\n\nfunction vec2f64_mag2(v = def_vec2f64) {\n  return +(+(+v.x * +v.x) + +(+v.y * +v.y));\n}\nfunction vec2f64_mag(v = def_vec2f64) {\n  return +mathf64_sqrt(+vec2f64_mag2(v));\n}\nfunction vec2f64_dist2(a = def_vec2f64, b = def_vec2f64) {\n  const dx = +(+b.x - +a.x), dy = +(+b.y - +a.y);\n  return +(+(+dx * +dx) + +(+dy * +dy));\n}\nfunction vec2f64_dist(a = def_vec2f64, b = def_vec2f64) {\n  return +mathf64_sqrt(+vec2f64_dist2(a, b));\n}\n\nfunction vec2f64_dot(a = def_vec2f64, b = def_vec2f64) {\n  return +(+(+a.x * +b.x) + +(+a.y * +b.y));\n}\nfunction vec2f64_cross(a = def_vec2f64, b = def_vec2f64) {\n  return +(+(+a.x * +b.y) - +(+a.y * +b.x));\n}\nfunction vec2f64_cross3(a = def_vec2f64, b = def_vec2f64, c = def_vec2f64) {\n  return +(\n    +(+(+b.x - +a.x) * +(+c.y - +a.y))\n    - +(+(+b.y - +a.y) * +(+c.x - +a.x))\n  );\n}\n\nfunction vec2f64_theta(v = def_vec2f64) {\n  return +mathf64_atan2(+v.y, +v.x);\n}\nfunction vec2f64_phi(v = def_vec2f64) {\n  return +mathf64_asin(+v.y / +vec2f64_mag(v));\n}\n\n//#endregion\n\n//#region flat vec2f pure advanced vector functions\nfunction vec2f64_unit(v = def_vec2f64) {\n  const mag2 = +vec2f64_mag2();\n  return vec2f64_divs(\n    v,\n    +(mag2 > 0 ? 1.0 / +mathf64_sqrt(mag2) : 1),\n  );\n}\n\nfunction vec2f64_lerp(v = 0.0, a = def_vec2f64, b = def_vec2f64) {\n  const ax = +a.x, ay = +ay.y;\n  return new vec2f64(\n    +(ax + +v * (+b.x - ax)),\n    +(ay + +v * (+b.y - ay)),\n  );\n}\n\nfunction vec2f64_rotn90(v = def_vec2f64) {\n  return new vec2f64(\n    +v.y,\n    +(-(+v.x)),\n  );\n}\nfunction vec2f64_rot90(v = def_vec2f64) {\n  return new vec2f64(\n    +(-(+v.y)),\n    +v.x,\n  );\n}\n\n/**\n * Rotates a vector by the specified angle in radians\n *\n * @param {float} r  angle in radians\n * @returns {vec2f} transformed output vector\n */\nfunction vec2f64_rotate(v = def_vec2f64, radians = 0.0) {\n  return new vec2f64(\n    +(+(+v.x * +mathf64_cos(+radians)) - +(+v.y * +mathf64_sin(+radians))),\n    +(+(+v.x * +mathf64_sin(+radians)) + +(+v.y * +mathf64_cos(+radians))),\n  );\n}\nfunction vec2f64_about(a = def_vec2f64, b = def_vec2f64, radians = 0.0) {\n  return new vec2f64(\n    +(+b.x\n      + +(+(+(+a.x - +b.x) * +mathf64_cos(+radians))\n      - +(+(+a.y - +b.y) * +mathf64_sin(+radians)))),\n    +(+b.y\n      + +(+(+(+a.x - +b.x) * +mathf64_sin(+radians))\n      + +(+(+a.y - +b.y) * +mathf64_cos(+radians)))),\n  );\n}\n\n\n//#endregion\n\n//#region flat vec2f impure advanced vector functions\n\nfunction vec2f64_iunit(v = def_vec2f64) {\n  return vec2f64_idivs(+vec2f64_mag(v));\n}\n\nfunction vec2f64_irotn90(v = def_vec2f64) {\n  v.x = +v.y;\n  v.y = +(-(+v.x));\n  return v;\n}\nfunction vec2f64_irot90(v = def_vec2f64) {\n  v.x = +(-(+v.y));\n  v.y = +v.x;\n  return v;\n}\nconst vec2f64_iperp = vec2f64_irot90;\n\nfunction vec2f64_irotate(v = def_vec2f64, radians = 0.0) {\n  v.x = +(+(+v.x * +mathf64_cos(+radians)) - +(+v.y * +mathf64_sin(+radians)));\n  v.y = +(+(+v.x * +mathf64_sin(+radians)) + +(+v.y * +mathf64_cos(+radians)));\n  return v;\n}\nfunction vec2f64_iabout(a = def_vec2f64, b = def_vec2f64, radians = 0.0) {\n  a.x = +(+b.x + +(+(+(+a.x - +b.x) * +mathf64_cos(+radians))\n    - +(+(+a.y - +b.y) * +mathf64_sin(+radians))));\n  a.y = +(+b.y + +(+(+(+a.x - +b.x) * +mathf64_sin(+radians))\n    + +(+(+a.y - +b.y) * +mathf64_cos(+radians))));\n  return a;\n}\n\n//#endregion\n\n//#endregion\n\nconst def_vec2f64 = Object.freeze(Object.seal(vec2f64_new()));\nfunction vec2f64_new(x = 0.0, y = 0.0) { return new vec2f64(+x, +y); }\n\nvar float64Vec2 = {\n  vec2: vec2f64,\n  default: def_vec2f64,\n\n  neg: vec2f64_neg,\n  add: vec2f64_add,\n  adds: vec2f64_adds,\n  addms: vec2f64_addms,\n  sub: vec2f64_sub,\n  subs: vec2f64_subs,\n  mul: vec2f64_mul,\n  muls: vec2f64_muls,\n  div: vec2f64_div,\n  divs: vec2f64_divs,\n  inv: vec2f64_inv,\n  ceil: vec2f64_ceil,\n  floor: vec2f64_floor,\n  round: vec2f64_round,\n  min: vec2f64_min,\n  max: vec2f64_max,\n\n  ineg: vec2f64_ineg,\n  iadd: vec2f64_iadd,\n  iadds: vec2f64_iadds,\n  iaddms: vec2f64_iaddms,\n  isub: vec2f64_isub,\n  isubs: vec2f64_isubs,\n  imul: vec2f64_imul,\n  imuls: vec2f64_imuls,\n  idiv: vec2f64_idiv,\n  idivs: vec2f64_idivs,\n  iinv: vec2f64_iinv,\n  iceil: vec2f64_iceil,\n  ifloor: vec2f64_ifloor,\n  iround: vec2f64_iround,\n  imin: vec2f64_imin,\n  imax: vec2f64_imax,\n\n  eqstrict: vec2f64_eqstrict,\n  eq: vec2f64_eq,\n\n  mag2: vec2f64_mag2,\n  mag: vec2f64_mag,\n  dist2: vec2f64_dist2,\n  dist: vec2f64_dist,\n  dot: vec2f64_dot,\n  cross: vec2f64_cross,\n  cross3: vec2f64_cross3,\n  theta: vec2f64_theta,\n  angle: vec2f64_theta,\n  phi: vec2f64_phi,\n\n  unit: vec2f64_unit,\n  lerp: vec2f64_lerp,\n  rotn90: vec2f64_rotn90,\n  rot90: vec2f64_rot90,\n  perp: vec2f64_rot90,\n  rotate: vec2f64_rotate,\n  about: vec2f64_about,\n\n  new: vec2f64_new,\n};\n\nclass vec3f64 {\n  constructor(x = 0.0, y = 0.0, z = 0.0) {\n    if (x instanceof vec2f64) {\n      this.x = +x.x;\n      this.y = +x.y;\n      this.z = +y;\n    }\n    else {\n      this.x = +x;\n      this.y = +y;\n      this.z = +z;\n    }\n  }\n}\n\nconst def_vec3f64 = Object.freeze(Object.seal(vec3f64_new()));\n\n//#region flat vec3f pure primitive operators\n\nfunction vec3f64_div(a = def_vec3f64, b = def_vec3f64) {\n  return new vec3f64(\n    +(+a.x / +b.x),\n    +(+a.y / +b.y),\n    +(+a.z / +b.z),\n  );\n}\nfunction vec3f64_divs(v = def_vec3f64, scalar = 0.0) {\n  return new vec3f64(\n    +(+v.x / +scalar),\n    +(+v.y / +scalar),\n    +(+v.z / +scalar),\n  );\n}\n\n//#endregion\n\n//#region flat vec3f impure primitive operators\n\nfunction vec3f64_idiv(a = def_vec3f64, b = def_vec3f64) {\n  a.x /= +(+b.x);\n  a.y /= +(+b.y);\n  a.z /= +(+b.z);\n  return a;\n}\nfunction vec3f64_idivs(v = def_vec3f64, scalar = 0.0) {\n  v.x /= +scalar;\n  v.y /= +scalar;\n  v.z /= +scalar;\n  return v;\n}\n\n//#endregion\n\n//#region flat vec3f pure advanced operators\n\nfunction vec3f64_mag2(v = def_vec3f64) {\n  return +(+(+v.x * +v.x) + +(+v.y * +v.y) + +(+v.z * +v.z));\n}\nfunction vec3f64_mag(v = def_vec3f64) {\n  return +mathf64_sqrt(+vec3f64_mag2(v));\n}\nfunction vec3f64_unit(v = def_vec3f64) {\n  return vec3f64_divs(v, +vec3f64_mag(v));\n}\nfunction vec3f64_iunit(v = def_vec3f64) {\n  return vec3f64_idivs(v, +vec3f64_mag(v));\n}\n\nfunction vec3f64_crossABAB(a = def_vec3f64, b = def_vec3f64) {\n  return new vec3f64(\n    +(+(+a.y * +b.z) - +(+a.z * +b.y)),\n    +(+(+a.z * +b.x) - +(+a.x * +b.z)),\n    +(+(+a.x * +b.y) - +(+a.y * +b.x)),\n  );\n}\n\n//#endregion\n\nfunction vec3f64_new(x = 0.0, y = 0.0, z = 0.0) { return new vec3f64(+x, +y, +z); }\n\n/* eslint-disable lines-between-class-members */\n\n\n//#region basic svg object\n//#endregion\n\n//#region vec2d basic shapes\n\nclass shape2f {\n  getP1X() { return this.gP1() ? this.gP1().x : Number.NaN; }\n  getP1Y() { return this.gP1() ? this.gP1().y : Number.NaN; }\n  getP2X() { return this.gP2() ? this.gP2().x : Number.NaN; }\n  getP2Y() { return this.gP2() ? this.gP2().y : Number.NaN; }\n  getP3X() { return this.gP3() ? this.gP3().x : Number.NaN; }\n  getP3Y() { return this.gP3() ? this.gP3().y : Number.NaN; }\n  getP4X() { return this.gP4() ? this.gP4().x : Number.NaN; }\n  getP4Y() { return this.gP4() ? this.gP4().y : Number.NaN; }\n  pointCount() { return 0.0; }\n}\n\nconst point2f_POINTS = 1;\nclass point2f extends shape2f {\n  constructor(p1 = def_vec2f64) {\n    super();\n    this.p1 = p1;\n  }\n\n  gP1() {\n    return this.p1;\n  }\n\n  pointCount() {\n    return point2f_POINTS;\n  }\n}\n\nconst circle2f_POINTS = 1;\nclass circle2f extends shape2f {\n  constructor(p1 = def_vec2f64, r = 1.0) {\n    super();\n    this.p1 = p1;\n    this.radius = +r;\n  }\n\n  gP1() {\n    return this.p1;\n  }\n\n  pointCount() {\n    return circle2f_POINTS;\n  }\n}\n\nconst rectangle2f_POINTS = 2;\nclass rectangle2f extends shape2f {\n  constructor(p1 = def_vec2f64, p2 = def_vec2f64) {\n    super();\n    this.p1 = p1;\n    this.p2 = p2;\n  }\n\n  gP1() {\n    return this.p1;\n  }\n\n  gP2() {\n    return this.p2;\n  }\n\n  pointCount() {\n    return rectangle2f_POINTS;\n  }\n}\n\n// TODO: argument initialiser to def_triangle2f\n\nconst triangle2f_POINTS = 3;\nclass triangle2f extends shape2f {\n  constructor(p1 = def_vec2f64, p2 = def_vec2f64, p3 = def_vec2f64) {\n    super();\n    this.p1 = p1;\n    this.p2 = p2;\n    this.p3 = p3;\n  }\n\n  gP1() {\n    return this.p1;\n  }\n\n  gP2() {\n    return this.p2;\n  }\n\n  gP3() {\n    return this.p3;\n  }\n\n  pointCount() {\n    return triangle2f_POINTS;\n  }\n\n  //#region intersects other shape\n\n  intersectsRect(rectangle = rectangle2f, normal = 1.0) {\n    return triangle2f_intersectsRect(\n      this.p1,\n      this.p2,\n      this.p3,\n      rectangle.p1,\n      rectangle.p2,\n      +normal,\n    );\n  }\n\n  intersectsTangle(triangle = triangle2f) {\n    return triangle2f_intersectsTangle(\n      this.p1,\n      this.p2,\n      this.p3,\n      triangle.p1,\n      triangle.p2,\n      triangle.p3,\n    );\n  }\n  //#endregion\n}\n\n/**\n * Tests if triangle intersects with rectangle\n *\n * @param {rectangle2f} rectangle\n * @param {*} normal\n */\nfunction triangle2f_intersectsRect(\n  l1 = def_vec2f64, l2 = def_vec2f64, l3 = def_vec2f64,\n  r1 = def_vec2f64, r2 = def_vec2f64, normal = 1.0,\n) {\n  normal = +normal;\n  const dx = +(+r2.x - +r1.x);\n  const dy = +(+r2.y - +r1.y);\n  return !(\n    (((+l1.x - +r1.x) * +dy - (+l1.y - +r1.y) * +dx) * +normal < 0)\n    || (((+l2.x - +r1.x) * +dy - (+l2.y - +r1.y) * +dx) * +normal < 0)\n    || (((+l3.x - +r1.x) * +dy - (+l3.y - +r1.y) * +dx) * +normal < 0));\n}\nfunction triangle2f_intersectsTangle(\n  l1 = def_vec2f64, l2 = def_vec2f64, l3 = def_vec2f64,\n  r1 = def_vec2f64, r2 = def_vec2f64, r3 = def_vec2f64,\n) {\n  const lnorm = +(\n    +(+(+l2.x - +l1.x) * +(+l3.y - +l1.y))\n    - +(+(+l2.y - +l1.y) * +(+l3.x - +l1.x)));\n  const rnorm = +(\n    +(+(+r2.x - +r1.x) * +(+r3.y - +r1.y))\n    - +(+(+r2.y - +r1.y) * +(+r3.x - +r1.x)));\n\n  return !(triangle2f_intersectsRect(r1, r2, r3, l1, l2, lnorm)\n    || triangle2f_intersectsRect(r1, r2, r3, l2, l3, lnorm)\n    || triangle2f_intersectsRect(r1, r2, r3, l3, l1, lnorm)\n    || triangle2f_intersectsRect(l1, l2, l3, r1, r2, rnorm)\n    || triangle2f_intersectsRect(l1, l2, l3, r2, r3, rnorm)\n    || triangle2f_intersectsRect(l1, l2, l3, r3, r1, rnorm));\n}\n\nconst trapezoid2f_POINTS = 4;\nclass trapezoid2f extends shape2f {\n  constructor(p1 = def_vec2f64, p2 = def_vec2f64, p3 = def_vec2f64, p4 = def_vec2f64) {\n    super();\n    this.p1 = p1;\n    this.p2 = p2;\n    this.p3 = p3;\n    this.p4 = p4;\n  }\n\n  gP1() {\n    return this.p1;\n  }\n\n  gP2() {\n    return this.p2;\n  }\n\n  gP3() {\n    return this.p3;\n  }\n\n  gP4() {\n    return this.p4;\n  }\n\n  pointCount() {\n    return rectangle2f_POINTS;\n  }\n}\n\n\n//#endregion\n\n//#region svg path segments\n\nclass segm2f {\n  constructor(abs = true) {\n    this.abs = (typeof abs === 'boolean')\n      ? abs // is the coordinate absolute or relative?\n      : true;\n  }\n\n  gAbs() {\n    return this.abs;\n  }\n\n  isValidPrecursor(segment) {\n    return (segment === undefined || segment === null)\n      || ((segment instanceof segm2f) && !(segment instanceof segm2f_Z));\n  }\n}\n\nclass segm2f_M extends segm2f {\n  constructor(abs = true, x = 0.0, y = 0.0) {\n    super(abs);\n    this.p1 = (x instanceof vec2f64)\n      ? x\n      : new vec2f64(+x, +y);\n  }\n\n  gP1() {\n    return this.p1;\n  }\n}\n\nclass segm2f_v extends segm2f {\n  constructor(abs = false, y = 0.0) {\n    super(abs);\n    this.y = (y instanceof vec2f64)\n      ? this.y = y.y\n      : y;\n  }\n\n  gY() {\n    return +this.y;\n  }\n\n  gP1() {\n    return new vec2f64(0.0, +this.y);\n  }\n}\nclass segm2f_h extends segm2f {\n  constructor(abs = false, x = 0.0) {\n    super(abs);\n    this.x = +x;\n  }\n\n  gX() {\n    return +this.x;\n  }\n\n  gP1() {\n    return new vec2f64(+this.x, 0.0);\n  }\n}\nclass segm2f_l extends segm2f {\n  constructor(abs = false, p1 = def_vec2f64, y = 0.0) {\n    super(abs);\n    this.p1 = (p1 instanceof vec2f64)\n      ? p1\n      : new vec2f64(+p1, +y);\n  }\n}\n\nclass segm2f_q extends segm2f {\n  constructor(abs = false, p1 = def_vec2f64, p2 = def_vec2f64, x2 = 0.0, y2 = 0.0) {\n    super(abs);\n    if (p1 instanceof vec2f64) {\n      this.p1 = p1;\n      if (p2 instanceof vec2f64) {\n        this.p2 = p2;\n      }\n      else {\n        this.p2 = new vec2f64(+p2, +x2);\n      }\n    }\n    else {\n      this.p1 = new vec2f64(+p1, +p2);\n      this.p2 = new vec2f64(+x2, +y2);\n    }\n  }\n\n  gP1() {\n    return this.p1;\n  }\n\n  gP2() {\n    return this.p2;\n  }\n}\nclass segm2f_t extends segm2f {\n  constructor(abs = false, p1 = def_vec2f64, y = 0.0) {\n    super(abs);\n    this.p1 = (p1 instanceof vec2f64)\n      ? p1\n      : new vec2f64(+p1, +y);\n  }\n\n  hasValidPrecursor(segment) {\n    return (segment instanceof segm2f_t)\n      || (segment instanceof segm2f_q);\n  }\n}\n\nclass segm2f_c extends segm2f {\n  constructor(abs = false) {\n    super(abs);\n    // TODO\n  }\n}\n\nclass segm2f_s extends segm2f {\n  constructor(abs = false) {\n    super(abs);\n    // TODO\n  }\n\n  hasValidPrecursor(segment) {\n    return (segment instanceof segm2f_s)\n      || (segment instanceof segm2f_c);\n  }\n}\n\nclass segm2f_Z extends segm2f {\n  constructor() {\n    super(true);\n  }\n\n  hasValidPrecursor(segment) {\n    return !(segment instanceof segm2f_Z);\n  }\n}\n//#endregion\n\n//#region svg path object path2f\nclass path2f extends shape2f {\n  constructor(abs = false, list = []) {\n    super(abs);\n    this.list = list;\n  }\n\n  isClosed() {\n    const list = this.list;\n    const len = list.length;\n    return (len > 0 && (list[len - 1] instanceof segm2f_Z));\n  }\n\n  add(segment) {\n    if (segment instanceof segm2f) {\n      const list = this.list;\n      const len = list.length;\n      if (segment.hasValidPrecursor(len > 0 ? list[len - 1] : null)) {\n        list[len] = segment;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  move(abs, x, y) {\n    const segm = new segm2f_M(abs, x, y);\n    return this.add(segm);\n  }\n\n  vertical(abs, y) {\n    const segm = new segm2f_v(abs, y);\n    return this.add(segm);\n  }\n\n  horizontal(abs, x) {\n    const segm = new segm2f_h(abs, x);\n    return this.add(segm);\n  }\n\n  line(abs, x, y) {\n    const segm = new segm2f_l(abs, x, y);\n    return this.add(segm);\n  }\n\n  close() {\n    const segm = new segm2f_Z();\n    return this.add(segm);\n  }\n}\n\n//#endregion\n\n/* eslint-disable prefer-rest-params */\nfunction getFirstObjectItem(items) {\n  for (const item in items) {\n    if (!items.hasOwnProperty(item)) continue;\n    return item;\n  }\n  return undefined;\n}\n\nfunction clone(target, source) {\n  const out = {};\n\n  for (const t in target) {\n    if (target.hasOwnProperty(t)) out[t] = target[t];\n  }\n  for (const s in source) {\n    if (source.hasOwnProperty(s)) out[s] = source[s];\n  }\n  return out;\n}\n\nfunction cloneDeep(o) {\n  if (typeof o !== 'object') {\n    return o;\n  }\n  if (!o) {\n    return o;\n  }\n\n  if (o instanceof Array) {\n    const newO = [];\n    for (let i = 0; i < o.length; i += 1) {\n      newO[i] = cloneDeep(o[i]);\n    }\n    return newO;\n  }\n  else {\n    const newO = {};\n    const keys = Reflect.ownKeys(o);\n    for (const i in keys) {\n      if (keys.hasOwnProperty(i)) {\n        newO[i] = cloneDeep(o[i]);\n      }\n    }\n    return newO;\n  }\n}\n\nfunction mergeObjects(target, ...rest) {\n  const ln = rest.length;\n  const mergeFn = mergeObjects;\n\n  let i = 0;\n  for (; i < ln; i++) {\n    const object = rest[i];\n    for (const key in object) {\n      if (object.hasOwnProperty(key)) {\n        const value = object[key];\n        if (value && value.constructor === Object) {\n          const sourceKey = target[key];\n          mergeFn(sourceKey, value);\n        }\n        else {\n          target[key] = value;\n        }\n      }\n    }\n  }\n  return target;\n}\n\n// e3Merge from https://jsperf.com/merge-two-arrays-keeping-only-unique-values/22\nfunction mergeArrays(a, b) {\n  const hash = {};\n  let i = (a = a.slice(0)).length;\n\n  while (i--) {\n    hash[a[i]] = 1;\n  }\n\n  for (i = 0; i < b.length; i++) {\n    const e = b[i];\n    // eslint-disable-next-line no-unused-expressions\n    hash[e] || a.push(e);\n  }\n\n  return a;\n}\n\nfunction collapseNear(rest) {\n  const result = [];\n  let cursor = 0;\n\n  const lenx = rest.length;\n  let itemx = null;\n  let ix = 0;\n\n\n  let leny = 0;\n  let itemy = null;\n  let iy = 0;\n\n  // fill the children array with the rest parameters\n  while (ix < lenx) {\n    itemx = rest[ix];\n    ++ix;\n    if (itemx === undefined || itemx === null || itemx === false || itemx === true) continue;\n    if (itemx.pop) {\n      // this is an array so fill the children array with the items of this one\n      // we do not go any deeper!\n      leny = itemx.length;\n      iy = 0;\n      while (iy < leny) {\n        itemy = itemx[iy];\n        ++iy;\n        if (itemy === undefined || itemy === null || itemy === false || itemy === true) continue;\n        result[cursor++] = itemy;\n      }\n    }\n    else {\n      result[cursor++] = itemx;\n    }\n  }\n  return result;\n}\n\n//#region\n/* -----------------------------------------------------------------------------------------\n    deepEquals( a, b [, enforce_properties_order, cyclic] )\n    https://stackoverflow.com/a/6713782/4598221\n\n    Returns true if a and b are deeply equal, false otherwise.\n\n    Parameters:\n      - a (Any type): value to compare to b\n      - b (Any type): value compared to a\n\n    Optional Parameters:\n      - enforce_properties_order (Boolean): true to check if Object properties are provided\n        in the same order between a and b\n\n      - cyclic (Boolean): true to check for cycles in cyclic objects\n\n    Implementation:\n      'a' is considered equal to 'b' if all scalar values in a and b are strictly equal as\n      compared with operator '===' except for these two special cases:\n        - 0 === -0 but are not equal.\n        - NaN is not === to itself but is equal.\n\n      RegExp objects are considered equal if they have the same lastIndex, i.e. both regular\n      expressions have matched the same number of times.\n\n      Functions must be identical, so that they have the same closure context.\n\n      \"undefined\" is a valid value, including in Objects\n\n      106 automated tests.\n\n      Provide options for slower, less-common use cases:\n\n        - Unless enforce_properties_order is true, if 'a' and 'b' are non-Array Objects, the\n          order of occurence of their attributes is considered irrelevant:\n            { a: 1, b: 2 } is considered equal to { b: 2, a: 1 }\n\n        - Unless cyclic is true, Cyclic objects will throw:\n            RangeError: Maximum call stack size exceeded\n*/\nfunction deepEquals(a, b, enforce_properties_order, cyclic) {\n  /* -----------------------------------------------------------------------------------------\n    reference_equals( a, b )\n\n    Helper function to compare object references on cyclic objects or arrays.\n\n    Returns:\n      - null if a or b is not part of a cycle, adding them to object_references array\n      - true: same cycle found for a and b\n      - false: different cycle found for a and b\n\n    On the first call of a specific invocation of equal(), replaces self with inner function\n    holding object_references array object in closure context.\n\n    This allows to create a context only if and when an invocation of equal() compares\n    objects or arrays.\n  */\n  function reference_equals(a1, b1) {\n    const object_references = [];\n\n    function _reference_equals(a2, b2) {\n      let l = object_references.length;\n\n      while (l--) {\n        if (object_references[l--] === b2) {\n          return object_references[l] === a2;\n        }\n      }\n      object_references.push(a2, b2);\n      return null;\n    }\n\n    return _reference_equals(a1, b1);\n  }\n\n\n  function _equals(a1, b1) {\n    // They should have the same toString() signature\n    const s = toString.call(a1);\n    if (s !== toString.call(b1)) return false;\n\n    switch (s) {\n      default: // Boolean, Date, String\n        return a1.valueOf() === b1.valueOf();\n\n      case '[object Number]':\n        // Converts Number instances into primitive values\n        // This is required also for NaN test bellow\n        a1 = +a1;\n        b1 = +b1;\n\n        // return a ?         // a is Non-zero and Non-NaN\n        //     a === b\n        //   :                // a is 0, -0 or NaN\n        //     a === a ?      // a is 0 or -0\n        //     1/a === 1/b    // 1/0 !== 1/-0 because Infinity !== -Infinity\n        //   : b !== b;        // NaN, the only Number not equal to itself!\n        // ;\n\n        // eslint-disable-next-line no-nested-ternary\n        return a1\n          ? a1 === b1\n          // eslint-disable-next-line no-self-compare\n          : a1 === a1\n            ? 1 / a1 === 1 / b1\n            // eslint-disable-next-line no-self-compare\n            : b1 !== b1;\n\n      case '[object RegExp]':\n        return a1.source === b1.source\n          && a1.global === b1.global\n          && a1.ignoreCase === b1.ignoreCase\n          && a1.multiline === b1.multiline\n          && a1.lastIndex === b1.lastIndex;\n\n      case '[object Function]':\n        return false; // functions should be strictly equal because of closure context\n\n      case '[object Array]': {\n        const r = reference_equals(a1, b1);\n        if ((cyclic && r) !== null) return r; // intentionally duplicated bellow for [object Object]\n\n        let l = a1.length;\n        if (l !== b1.length) return false;\n        // Both have as many elements\n\n        while (l--) {\n          const x = a1[l];\n          const y = b1[l];\n          if (x === y && x !== 0 || _equals(x, y)) continue;\n\n          return false;\n        }\n\n        return true;\n      }\n\n      case '[object Object]': {\n        const r = reference_equals(a1, b1);\n        // intentionally duplicated from above for [object Array]\n        if ((cyclic && r) !== null) return r;\n\n        if (enforce_properties_order) {\n          const properties = [];\n\n          for (const p in a1) {\n            if (a1.hasOwnProperty(p)) {\n              properties.push(p);\n              const x = a1[p];\n              const y = b1[p];\n              if (x === y && x !== 0 || _equals(x, y)) continue;\n              return false;\n            }\n          }\n\n          // Check if 'b' has as the same properties as 'a' in the same order\n          let l = 0;\n          for (const p in b1) {\n            if (b1.hasOwnProperty(p)) {\n              if (properties[l] !== p) return false;\n              l++;\n            }\n          }\n        }\n        else {\n          let l = 0;\n          for (const p in a1) {\n            if (a1.hasOwnProperty(p)) {\n              ++l;\n              const x = a1[p];\n              const y = b1[p];\n              if (x === y && x !== 0 || _equals(x, y)) continue;\n\n              return false;\n            }\n          }\n          // Check if 'b' has as not more own properties than 'a'\n          for (const p in b1) {\n            if (b1.hasOwnProperty(p) && --l < 0) return false;\n          }\n        }\n        return true;\n      }\n    }\n  }\n\n  return a === b // strick equality should be enough unless zero\n    && a !== 0 // because 0 === -0, requires test by _equals()\n    || _equals(a, b); // handles not strictly equal or zero values\n}\n\n//#endregion\n\nfunction copyAttributes(src, dst) {\n  if (src.hasAttributes()) {\n    const attr = src.attributes;\n    const l = attr.length;\n    for (let i = 0; i < l; ++i) {\n      dst.setAttribute(attr[i].name, attr[i].value);\n    }\n  }\n}\n\nfunction fetchImage(htmlElement, clientWidth, clientHeight) {\n  return new Promise(function fetchImage_Promise(resolve, reject) {\n    if (typeof htmlElement === 'string') {\n      htmlElement = htmlElement.replace(/[\\s\\\"\\']+/g, '');\n      htmlElement = htmlElement.replace(/^url\\(/, '');\n      htmlElement = htmlElement.replace(/\\)$/, '');\n      const img = new Image();\n      img.onload = function fetchImage_image_onload() { resolve(img); };\n      img.onerror = function fetchImage_image_onerror(err) { reject(err); };\n      img.src = htmlElement;\n    }\n    else if (typeof htmlElement !== 'object') {\n      throw new Error('Where Am I??');\n    }\n    else if (htmlElement instanceof HTMLImageElement) {\n      if (htmlElement.complete) {\n        resolve(htmlElement);\n      }\n      else {\n        htmlElement.onload = function fetchImage_htmlElement_onload() { resolve(htmlElement); };\n        htmlElement.onerror = function fetchImage_htmlElement_onerror(err) { reject(err); };\n      }\n    }\n    else if (htmlElement instanceof Promise) {\n      htmlElement\n        .then(function fetchImage_Promise_then(imageElement) {\n          if (imageElement instanceof HTMLImageElement) {\n            resolve(imageElement);\n          }\n          else {\n            // eslint-disable-next-line prefer-promise-reject-errors\n            reject('ERR: fetchImage: Promise of first argument must resolve in HTMLImageElement!');\n          }\n        })\n        .catch(function fetchImage_Promise_catch(err) { reject(err); });\n    }\n    else if (htmlElement instanceof SVGSVGElement) {\n      if (htmlElement.firstElementChild.nodeName === 'foreignObject') {\n        let width = htmlElement.clientWidth;\n        let height = htmlElement.clientHeight;\n\n        width = htmlElement.firstElementChild.firstElementChild.clientWidth;\n        height = htmlElement.firstElementChild.firstElementChild.clientHeight;\n        // set the svg element size to match our canvas size.\n        htmlElement.setAttribute('width', width);\n        htmlElement.setAttribute('height', height);\n        // now copy a string of the complete element and its children\n        const svg = htmlElement.outerHTML;\n\n        const blob = new Blob([svg], { type: 'image/svg+xml' });\n        const url = window.URL.createObjectURL(blob);\n\n        const img = new Image();\n        img.onload = function fetchImage_SVGSVGElement_onload() {\n          window.URL.revokeObjectURL(url);\n          resolve(img);\n        };\n        img.onerror = function fetchImage_SVGSVGElement_onerror(err) {\n          window.URL.revokeObjectURL(url);\n          reject(err);\n        };\n        // trigger render of object url.\n        img.src = url;\n      }\n    }\n    else if (htmlElement instanceof HTMLElement) {\n      let width = htmlElement.clientWidth;\n      let height = htmlElement.clientHeight;\n\n      width = clientWidth ? clientWidth : width;\n      height = clientHeight ? clientHeight : height;\n\n      width = width === 0 ? 300 : width;\n      height = height === 0 ? 200 : height;\n\n      const svg = ('<svg xmlns=\"http://www.w3.org/2000/svg\"'\n        + ' width=\"' + width + '\"'\n        + ' height=\"' + height + '\">'\n        + '<foreignObject width=\"100%\" height=\"100%\">'\n        + htmlElement.outerHTML\n        + '</foreignObject>'\n        + '</svg>');\n\n      const blob = new Blob([svg], { type: 'image/svg+xml' });\n      const url = window.URL.createObjectURL(blob);\n\n      const img = new Image();\n      img.onload = function fetchImage_HTMLElement_onload() {\n        window.URL.revokeObjectURL(url);\n        resolve(img);\n      };\n      img.onerror = function fetchImage_HTMLElement_onerror(err) {\n        window.URL.revokeObjectURL(url);\n        reject(err);\n      };\n      // trigger render of object url.\n      img.src = url;\n    }\n    else {\n      // eslint-disable-next-line prefer-promise-reject-errors\n      reject('ERR: fetchImage: first argument MUST be of type url, HTMLElement or Promise!');\n    }\n  });\n}\n\nfunction collapseToString(source, matchRegEx) {\n  let r = '';\n  if (!source) {\n    return r;\n  }\n  else if (typeof source !== 'object') {\n    r = String(source).trim();\n\n    if (!matchRegEx) return r;\n    if (r === '') return r;\n\n    const m = r.match(matchRegEx);\n    if (!m) return '';\n    if (m.length !== 1) return '';\n    return r === m[0] && r;\n  }\n  else if (source.pop) {\n    const al = source.length;\n    let i = 0;\n    for (; i < al; ++i) {\n      const v = source[i];\n      if (v) {\n        r += collapseToString(v);\n        r += ' ';\n      }\n    }\n    return r.trim();\n  }\n  else {\n    for (const j in source) {\n      if (source.hasOwnProperty(j)) {\n        r += collapseToString(source[j]);\n        r += ' ';\n      }\n    }\n    return r.trim();\n  }\n}\n\nconst matchClassName = /[a-zA-Z_][a-zA-Z0-9_-]*/g;\nfunction collapseCssClass(...source) {\n  if (!source) return '';\n  const cl = source.length;\n  if (cl === 0) return '';\n  let i = 0;\n  let r = '';\n  for (; i < cl; ++i) {\n    const a = source[i];\n    if (a) {\n      r += collapseToString(a, matchClassName);\n      r += ' ';\n    }\n  }\n  return r.trim();\n}\n\nconst matchEmpty = [null, 0, -1, 0];\nfunction matchCssClass(node, name) {\n  if (!node || !name) return matchEmpty;\n\n  name = String(name);\n  const nl = name.length;\n  if (nl === 0) return matchEmpty;\n\n  const nodeClass = node.className;\n  const cl = nodeClass.length;\n  if (cl === 0) return matchEmpty;\n\n  let i = -1;\n  let n = 0;\n  let c = '';\n  for (i = nodeClass.indexOf(name); i < cl; i = nodeClass.indexOf(name, n)) {\n    if (i === -1) return matchEmpty;\n    n = i + nl;\n    if (n === cl) break;\n    c = nodeClass[n];\n    if (c === ' ' || c === '\\t') break;\n    i = -1;\n  }\n\n  return (i === -1) ? matchEmpty : [nodeClass, cl, i, n];\n}\n\nfunction hasCssClass(node, name) {\n  return matchCssClass(node, name) === matchEmpty;\n}\n\nfunction addCssClass(node, name) {\n  const [nodeClass,, i] = matchCssClass(node, name);\n  if (i === -1) {\n    node.className = nodeClass.trim() + ' ' + name;\n    return true;\n  }\n  return false;\n}\n\nfunction removeCssClass(node, name) {\n  const [nodeClass, cl, i, n] = matchCssClass(node, name);\n  if (i === -1) return false;\n\n  const left = i > 0 ? nodeClass.slice(0, i).trim() : '';\n  const right = n < cl ? nodeClass.slice(n).trim() : '';\n  if (left === '') {\n    node.className = right;\n  }\n  else if (right === '') {\n    node.className = left;\n  }\n  else {\n    node.className = left + ' ' + right;\n  }\n  return true;\n}\n\nfunction toggleCssClass(node, name) {\n  if (!addCssClass(node, name)) return removeCssClass(node, name);\n  return true;\n}\n\n/* eslint-disable no-undef */\n// a dummy function to mimic the CSS-Paint-Api-1 specification\nconst myRegisteredPaint__store__ = {};\nconst myRegisterPaint = typeof registerPaint !== 'undefined'\n  ? registerPaint\n  : (function myRegisterPaint_initFunction() {\n    return function myRegisterPaint_registerPaint__(name, paintClass) {\n      if (!myRegisteredPaint__store__.hasOwnProperty(name)) {\n        myRegisteredPaint__store__[name] = paintClass;\n      }\n    };\n  })();\n\nconst workletState = Object.freeze(Object.seal({\n  init: 0,\n  loading: 1,\n  preparing: 2,\n  running: 3,\n  exiting: 4,\n  ended: 5,\n}));\n\nclass vnode {\n  constructor(name, attributes, children) {\n    this.key = attributes.key;\n    this.attributes = attributes;\n    this.nodeName = name;\n    this.children = children;\n  }\n}\n\nfunction VN(name, attributes, ...rest) {\n  attributes = attributes || {};\n  const children = collapseNear(rest);\n  return typeof name === 'function'\n    ? name(attributes, children)\n    : new vnode(name, attributes, children);\n}\n\nconst h = VN;\n\nfunction wrapVN(name, type) {\n  if (type === undefined) {\n    return function wrapVN_common(attr, children) {\n      return VN(name, attr, children);\n    };\n  }\n  else {\n    return function wrapVN_astype(attr, children) {\n      return VN(name, { ...attr, type: type }, children);\n    };\n  }\n  // return (attr, children) => h(name, attr, children);\n}\n\n/* eslint-disable object-shorthand */\n\nfunction app(state, actions, view, container) {\n  const map = [].map;\n  let rootElement = (container && container.children[0]) || null;\n  let _oldNode = rootElement && recycleElement(rootElement);\n  const lifecycle = [];\n  let skipRender = false;\n  let isRecycling = true;\n  let globalState = clone(state);\n  const wiredActions = wireStateToActions([], globalState, clone(actions));\n\n  scheduleRender();\n\n  return wiredActions;\n\n  function recycleElement(element) {\n    return new vnode(\n      element.nodeName.toLowerCase(),\n      {},\n      map.call(element.childNodes, function recycleElement_inner(el) {\n        return el.nodeType === 3 // Node.TEXT_NODE\n          ? el.nodeValue\n          : recycleElement(el);\n      }),\n    );\n  }\n\n  function resolveNode(node) {\n    if (typeof node === 'function')\n      return resolveNode(node(globalState, wiredActions));\n    else\n      return node || '';\n    // : node != null ? node : '';\n  }\n\n  function render() {\n    skipRender = !skipRender;\n\n    const node = resolveNode(view);\n\n    if (container && !skipRender) {\n      rootElement = patch(container, rootElement, _oldNode, node);\n      _oldNode = node;\n    }\n\n    isRecycling = false;\n\n    while (lifecycle.length) lifecycle.pop()();\n  }\n\n  function scheduleRender() {\n    if (!skipRender) {\n      skipRender = true;\n      setTimeout(render);\n    }\n  }\n\n  function set(path, value, source) {\n    const target = {};\n    if (path.length) {\n      target[path[0]] = path.length > 1\n        ? set(path.slice(1), value, source[path[0]])\n        : value;\n      return clone(source, target);\n    }\n    return value;\n  }\n\n  function get(path, source) {\n    let i = 0;\n    const l = path.length;\n    while (i < l) {\n      source = source[path[i++]];\n    }\n    return source;\n  }\n\n  function wireStateToActions(path, myState, myActions) {\n    function createActionProxy(key, action) {\n      myActions[key] = function actionProxy(data) {\n        const slice = get(path, globalState);\n\n        let result = action(data);\n        if (typeof result === 'function') {\n          result = result(slice, myActions);\n        }\n\n        if (result && result !== slice && !result.then) {\n          globalState = set(path, clone(slice, result), globalState);\n          scheduleRender(globalState);\n        }\n\n        return result;\n      };\n    }\n\n    for (const key in myActions) {\n      if (typeof myActions[key] === 'function') {\n        createActionProxy(key, myActions[key]);\n      }\n      else {\n        // wire slice/namespace of state to actions\n        wireStateToActions(\n          path.concat(key),\n          (myState[key] = clone(myState[key])),\n          (myActions[key] = clone(myActions[key])),\n        );\n      }\n    }\n\n    return myActions;\n  }\n\n  function getKey(node) {\n    return node ? node.key : null;\n  }\n\n  function eventListener(event) {\n    return event.currentTarget.events[event.type](event);\n  }\n\n  function updateAttribute(element, name, value, oldValue, isSvg) {\n    if (name === 'style') {\n      if (typeof value === 'string') {\n        element.style.cssText = value;\n      }\n      else {\n        if (typeof oldValue === 'string') {\n          oldValue = element.style.cssText = '';\n        }\n        const lval = clone(oldValue, value);\n        for (const i in lval) {\n          if (lval.hasOwnProperty(i)) {\n            const style = (value == null || value[i] == null) ? '' : value[i];\n            if (i[0] === '-') {\n              element.style.setProperty(i, style);\n            }\n            else {\n              element.style[i] = style;\n            }\n          }\n        }\n      }\n    }\n    else if (name !== 'key') {\n      if (name.indexOf('on') === 0) {\n        name = name.slice(2);\n\n        if (element.events) {\n          if (!oldValue) oldValue = element.events[name];\n        }\n        else {\n          element.events = {};\n        }\n\n        element.events[name] = value;\n\n        if (value) {\n          if (!oldValue) {\n            element.addEventListener(name, eventListener);\n          }\n        }\n        else {\n          element.removeEventListener(name, eventListener);\n        }\n      }\n      else if (value != null && value !== false) {\n        if (name === 'class') {\n          const cls = collapseCssClass(value);\n          if (cls !== '')\n            element.className = collapseCssClass(value);\n          else\n            element.removeAttribute('class');\n        }\n        else if (name in element\n          && name !== 'list'\n          && name !== 'type'\n          && name !== 'draggable'\n          && name !== 'spellcheck'\n          && name !== 'translate'\n          && !isSvg) {\n          element[name] = value == null ? '' : value;\n        }\n        else {\n          element.setAttribute(name, value === true ? '' : value);\n        }\n      }\n      else {\n        element.removeAttribute(name);\n      }\n    }\n  }\n\n  function createElement(node, isSvg) {\n    const element = (typeof node === 'string' || typeof node === 'number')\n      ? document.createTextNode(node)\n      : (isSvg || node.nodeName === 'svg')\n        ? document.createElementNS('http://www.w3.org/2000/svg', node.nodeName)\n        : document.createElement(node.nodeName);\n\n    const attributes = node.attributes;\n    if (attributes) {\n      if (attributes.oncreate) {\n        lifecycle.push(function hyperapp_createElement_lifecycle() {\n          attributes.oncreate(element);\n        });\n      }\n\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i] = resolveNode(node.children[i]);\n        element.appendChild(createElement(child, isSvg));\n      }\n\n      for (const name in attributes) {\n        if (attributes.hasOwnProperty(name)) {\n          const value = attributes[name];\n          updateAttribute(element, name, value, null, isSvg);\n        }\n      }\n    }\n\n    return element;\n  }\n\n  function updateElement(element, oldAttributes, attributes, isSvg) {\n    for (const name in clone(oldAttributes, attributes)) {\n      // eslint-disable-next-line operator-linebreak\n      if (attributes[name] !==\n        (name === 'value' || name === 'checked'\n          ? element[name]\n          : oldAttributes[name])) {\n        updateAttribute(\n          element,\n          name,\n          attributes[name],\n          oldAttributes[name],\n          isSvg,\n        );\n      }\n    }\n\n    const cb = isRecycling ? attributes.oncreate : attributes.onupdate;\n    if (cb) {\n      lifecycle.push(function hyperapp_updateElement_lifecycle() {\n        cb(element, oldAttributes);\n      });\n    }\n  }\n\n  function removeChildren(element, node) {\n    const attributes = node.attributes;\n    if (attributes) {\n      for (let i = 0; i < node.children.length; i++) {\n        removeChildren(element.childNodes[i], node.children[i]);\n      }\n\n      if (attributes.ondestroy) {\n        attributes.ondestroy(element);\n      }\n    }\n    return element;\n  }\n\n  function removeElement(parent, element, node) {\n    function done() {\n      parent.removeChild(removeChildren(element, node));\n    }\n\n    const cb = node.attributes && node.attributes.onremove;\n    if (cb) {\n      cb(element, done);\n    }\n    else {\n      done();\n    }\n  }\n\n  function patch(parent, element, oldNode, node, isSvg) {\n    if (node !== oldNode) {\n      if (oldNode == null || oldNode.nodeName !== node.nodeName) {\n        const newElement = createElement(node, isSvg);\n        parent.insertBefore(newElement, element);\n\n        if (oldNode != null) {\n          removeElement(parent, element, oldNode);\n        }\n\n        element = newElement;\n      }\n      else if (oldNode.nodeName == null) {\n        element.nodeValue = node;\n      }\n      else {\n        updateElement(\n          element,\n          oldNode.attributes,\n          node.attributes,\n          (isSvg = isSvg || node.nodeName === 'svg'),\n        );\n\n        const oldKeyed = {};\n        const newKeyed = {};\n        const oldElements = [];\n        const oldChildren = oldNode.children;\n        const children = node.children;\n\n        for (let i = 0; i < oldChildren.length; i++) {\n          oldElements[i] = element.childNodes[i];\n\n          const oldKey = getKey(oldChildren[i]);\n          if (oldKey != null) {\n            oldKeyed[oldKey] = [oldElements[i], oldChildren[i]];\n          }\n        }\n\n        let i = 0;\n        let k = 0;\n        const l = children.length;\n        while (k < l) {\n          const oldKey = getKey(oldChildren[i]);\n          const newKey = getKey((children[k] = resolveNode(children[k])));\n\n          if (newKeyed[oldKey]) {\n            i++;\n            continue;\n          }\n\n          if (newKey == null || isRecycling) {\n            if (oldKey == null) {\n              patch(element, oldElements[i], oldChildren[i], children[k], isSvg);\n              k++;\n            }\n            i++;\n          }\n          else {\n            const keyedNode = oldKeyed[newKey] || [];\n\n            if (oldKey === newKey) {\n              patch(element, keyedNode[0], keyedNode[1], children[k], isSvg);\n              i++;\n            }\n            else if (keyedNode[0]) {\n              patch(\n                element,\n                element.insertBefore(keyedNode[0], oldElements[i]),\n                keyedNode[1],\n                children[k],\n                isSvg,\n              );\n            }\n            else {\n              patch(element, oldElements[i], null, children[k], isSvg);\n            }\n\n            newKeyed[newKey] = children[k];\n            k++;\n          }\n        }\n\n        while (i < oldChildren.length) {\n          if (getKey(oldChildren[i]) == null) {\n            removeElement(element, oldElements[i], oldChildren[i]);\n          }\n          i++;\n        }\n\n        for (const ik in oldKeyed) {\n          if (oldKeyed.hasOwnProperty(ik)) {\n            if (!newKeyed[ik]) {\n              removeElement(element, oldKeyed[ik][0], oldKeyed[ik][1]);\n            }\n          }\n        }\n      }\n    }\n    return element;\n  }\n}\n\nexport { VN, addCssClass, app, checkIfValueDisabled, circle2f, circle2f_POINTS, clone, cloneDeep, collapseCssClass, collapseNear, collapseToString, copyAttributes, deepEquals, def_vec2f64, def_vec2i32, def_vec3f64, float64Base as f64, fetchImage, float64_clamp, float64_clampu, float64_cosHp, float64_cosLp, float64_cosMp, float64_cross, float64_dot, float64_fib, float64_fib2, float64_gcd, float64_hypot, float64_hypot2, float64_inRange, float64_intersectsRange, float64_intersectsRect, float64_isqrt, float64_lerp, float64_map, float64_norm, float64_phi, float64_sinLp, float64_sinLpEx, float64_sinMp, float64_sinMpEx, float64_sqrt, float64_theta, float64_toDegrees, float64_toRadian, float64_wrapRadians, getFirstObjectItem, h, hasCssClass, int32Base as i32, int32_clamp, int32_clampu, int32_clampu_u8a, int32_clampu_u8b, int32_cross, int32_dot, int32_fib, int32_hypot, int32_hypotEx, int32_inRange, int32_intersectsRange, int32_intersectsRect, int32_lerp, int32_mag2, int32_map, int32_norm, int32_random, int32_sinLp, int32_sinLpEx, int32_sqrt, int32_sqrtEx, int32_toDegreesEx, int32_toRadianEx, int32_wrapRadians, isPrimitiveType, isPrimitiveTypeEx, isPureObject, float64Math as mathf64, mathf64_EPSILON, mathf64_PI, mathf64_PI1H, mathf64_PI2, mathf64_PI41, mathf64_PI42, mathf64_SQRTFIVE, mathf64_abs, mathf64_asin, mathf64_atan2, mathf64_ceil, mathf64_cos, mathf64_floor, mathf64_max, mathf64_min, mathf64_pow, mathf64_random, mathf64_round, mathf64_sin, mathf64_sqrt, int32Math as mathi32, mathi32_MULTIPLIER, mathi32_PI, mathi32_PI1H, mathi32_PI2, mathi32_PI41, mathi32_PI42, mathi32_abs, mathi32_asin, mathi32_atan2, mathi32_ceil, mathi32_floor, mathi32_max, mathi32_min, mathi32_round, mathi32_sqrt, mergeArrays, mergeObjects, myRegisterPaint, path2f, point2f, point2f_POINTS, rectangle2f, rectangle2f_POINTS, removeCssClass, sanitizePrimitiveValue, segm2f, segm2f_M, segm2f_Z, segm2f_c, segm2f_h, segm2f_l, segm2f_q, segm2f_s, segm2f_t, segm2f_v, shape2f, toggleCssClass, trapezoid2f, trapezoid2f_POINTS, triangle2f, triangle2f_POINTS, triangle2f_intersectsRect, triangle2f_intersectsTangle, triangle2i_intersectsRect, float64Vec2 as v2f64, int32Vec2 as v2i32, float64Vec2 as v3f64, vec2f64, vec2f64_about, vec2f64_add, vec2f64_addms, vec2f64_adds, vec2f64_ceil, vec2f64_cross, vec2f64_cross3, vec2f64_dist, vec2f64_dist2, vec2f64_div, vec2f64_divs, vec2f64_dot, vec2f64_eq, vec2f64_eqs, vec2f64_eqstrict, vec2f64_floor, vec2f64_iabout, vec2f64_iadd, vec2f64_iaddms, vec2f64_iadds, vec2f64_iceil, vec2f64_idiv, vec2f64_idivs, vec2f64_ifloor, vec2f64_iinv, vec2f64_imax, vec2f64_imin, vec2f64_imul, vec2f64_imuls, vec2f64_ineg, vec2f64_inv, vec2f64_iperp, vec2f64_irot90, vec2f64_irotate, vec2f64_irotn90, vec2f64_iround, vec2f64_isub, vec2f64_isubs, vec2f64_iunit, vec2f64_lerp, vec2f64_mag, vec2f64_mag2, vec2f64_max, vec2f64_min, vec2f64_mul, vec2f64_muls, vec2f64_neg, vec2f64_new, vec2f64_phi, vec2f64_rot90, vec2f64_rotate, vec2f64_rotn90, vec2f64_round, vec2f64_sub, vec2f64_subs, vec2f64_theta, vec2f64_unit, vec2i32, vec2i32_add, vec2i32_adds, vec2i32_angleEx, vec2i32_cross, vec2i32_cross3, vec2i32_div, vec2i32_divs, vec2i32_dot, vec2i32_iadd, vec2i32_iadds, vec2i32_idiv, vec2i32_idivs, vec2i32_imul, vec2i32_imuls, vec2i32_ineg, vec2i32_inorm, vec2i32_iperp, vec2i32_irot90, vec2i32_irotn90, vec2i32_isub, vec2i32_isubs, vec2i32_mag, vec2i32_mag2, vec2i32_mul, vec2i32_muls, vec2i32_neg, vec2i32_norm, vec2i32_perp, vec2i32_phiEx, vec2i32_rot90, vec2i32_rotn90, vec2i32_sub, vec2i32_subs, vec2i32_thetaEx, vec3f64, vec3f64_crossABAB, vec3f64_div, vec3f64_divs, vec3f64_idiv, vec3f64_idivs, vec3f64_iunit, vec3f64_mag, vec3f64_mag2, vec3f64_new, vec3f64_unit, vnode, workletState, wrapVN };\n//# sourceMappingURL=index.js.map\n","import {\n  mathf64_PI,\n  mathf64_abs,\n  mathf64_random,\n  mathf64_atan2,\n  mathf64_cos,\n  mathf64_max,\n  mathf64_sin,\n\n  float64_sqrt,\n  float64_hypot2,\n  float64_hypot,\n  float64_dot,\n  float64_theta\n} from 'futilsjs';\n\nexport class Boids {\n}\n\nconst CONST_DEFAULT_BOID_RADIUS = 21.5;\nconst CONST_DEFAULT_SPEED_LIMIT = mathf64_PI / 3;\n\nfunction initBoidsf(boidsf, count, size, viewport) {\n\n  // init boids randomly\n  for (let isrc = 0; isrc < count * size; isrc += size) {\n    // x-position\n    boidsf[isrc] = +mathf64_random() * viewport.width; // srcx\n    // y-position\n    boidsf[isrc + 1] = mathf64_random() * viewport.height; // srcy\n    // x-velocity\n    boidsf[isrc + 2] = +mathf64_sin(mathf64_random() * mathf64_PI * 2) * CONST_DEFAULT_SPEED_LIMIT;\n    // y-velocity\n    boidsf[isrc + 3] = +mathf64_sin(mathf64_random() * mathf64_PI * 2) * CONST_DEFAULT_SPEED_LIMIT;\n    // angle in unsigned radians\n    boidsf[isrc + 4] = (mathf64_random() * mathf64_PI * 2) - mathf64_PI;\n    // unsigned radiusX or width\n    boidsf[isrc + 5] = +mathf64_max(3, mathf64_abs(mathf64_sin((mathf64_random() * mathf64_PI * 2) - mathf64_PI)) * CONST_DEFAULT_BOID_RADIUS);\n    boidsf[isrc + 6] = 0;\n  }\n}\n\nexport default function createBoids(viewport = {}, boidCount = 52, maxSize = 254) {\n\n  const structSize = 7;\n  //const boids = new Int32Array(maxSize * structSize);\n  const boidsfBuffer1 = new Float64Array(maxSize * structSize); // boids.buffer);\n  const boidsfBuffer2 = new Float64Array(maxSize * structSize); // boids.buffer);\n\n  // setup buffer selector\n  let isBuffer1 = true;\n\n  initBoidsf(boidsfBuffer1, boidCount, structSize, viewport);\n\n  class BoidsImpl {\n    processFrame(options, callback) {\n\n      const vpwidth = options.width|0;\n      const vpheight = options.height|0;\n      \n      // rollup optimization strangeness fix\n      const buf1 = isBuffer1;\n\n      // get current buffer\n      const cboidsf = buf1 ? boidsfBuffer1 : boidsfBuffer2;\n      const nboidsf = buf1 ? boidsfBuffer2 : boidsfBuffer1;\n\n      // init flocking rules variable\n      let rulesvx = 0.0, rulesvy = 0.0, rulescnt = 0;\n      // init separation rule\n      let rule1vx = 0.0, rule1vy = 0.0, rule1cnt = 0;\n\n      // clean our canvas and iterate of all boids\n      let srcx = 0.0, srcy = 0.0;\n      let srcvx = 0.0, srcvy = 0.0;\n      let srca = 0.0, srcm = 0.0;\n      let srcw = 0.0, srch = 0.0;\n      let color = 'blue';\n\n      for (let isrc = 0; isrc < boidCount * structSize; isrc += structSize) {\n        srcx = +cboidsf[isrc]; // x position\n        srcy = +cboidsf[isrc + 1]; // y position\n        srcvx = +cboidsf[isrc + 2]; // x velocity\n        srcvy = +cboidsf[isrc + 3]; // y velocity\n        srca = +cboidsf[isrc + 4]; // angle (derived from vx/vy when mag > 0.0)\n        srch = +cboidsf[isrc + 5]; // height/radiusY\n        srcw = +(srch / 2.0);  // width/radiusX\n        srcm = +(srch * srcw) * 0.639; // mass\n        color = 'blue';\n\n        rulesvx = rule1vx = 0.0;\n        rulesvy = rule1vy = 0.0; \n        rulescnt = rule1cnt = 0;\n\n        // iterate through other boids\n        for (let ioth = 0; ioth < boidCount * structSize; ioth += structSize) {\n          if (ioth !== isrc) {\n            // load the other boid variables\n            const othx = +cboidsf[ioth];\n            const othy = +cboidsf[ioth + 1];\n            const othvx = +cboidsf[ioth + 2];\n            const othvy = +cboidsf[ioth + 3];\n            const otha = +cboidsf[ioth + 4];\n            const othh = +cboidsf[ioth + 5]; // height/radiusY\n            const othw = +(othh / 2.0); // width/radiusX\n            const othm = +(othh * othw) * 0.639; // mass\n\n            // compute distance from each other\n            const distx = +(othx - srcx);\n            const disty = +(othy - srcy);\n            const dist2 = +float64_hypot2(distx, disty);\n\n            // compute minimum distance from each other\n            const minwidth = +(srcw + othw);\n            const minheight = +(srch + othh);\n            const mindist2 = +float64_hypot2(minwidth, minheight);\n\n            // define maximum distance for entering branch\n            const maxdist = +(+mindist2 + +(mathf64_PI * mathf64_PI));\n            if (dist2 < mindist2) {\n              const distance = +float64_sqrt(dist2);\n              const mindistance = +float64_sqrt(mindist2);\n              \n              //#region RULE 1: Separation\n\n              // compute unit vector normal and tangent vectors\n              const unx = +(distx / distance); // unit normal vector x\n              const uny = +(disty / distance); // unit normal vector y\n              // vec2f_rotn90\n              const utx = +(-uny); // unit tangent vector x\n              const uty = +(unx); // unit tangent vector y\n              \n              // compute scalar projection of velocities\n              const svn = +float64_dot(unx, uny, srcvx, srcvy);\n              const svt = +float64_dot(utx, uty, srcvx, srcvy);\n              const ovn = +float64_dot(unx, uny, othvx, othvy);\n              // const ovt = +float64_dot(utx, uty, othvx, othvy);\n\n              // compute new velocity using 1 dimension\n              const svp = +((svn * (srcm - othm) + 2.0 * othm * ovn) / (srcm + othm));\n              // const ovp = +((ovn * (othm - srcm) + 2.0 * srcm * svn) / (srcm + othm));\n              \n              // compute new normal and tangent velocity vectors\n              const nnx = +(svp * unx); // nnv = unv * svp\n              const nny = +(svp * uny);\n              const ntx = +(svt * utx); // ntv = utv * svt;\n              const nty = +(svt * uty);\n              const nvx = +(nnx + ntx); // nvv = ntv + nnv;\n              const nvy = +(nny + nty);\n\n              // compute weights relative to distance\n              const reldist = 1.0; // +(1.0 / (+mathf64_abs(distance - mindist) + 1.0)); \n              rule1vx += +(nvx * reldist);\n              rule1vy += +(nvy * reldist);\n              rule1cnt++;\n\n              //#endregion\n              \n            }\n          }\n        }\n\n        // compute separation rule\n        if (rule1cnt > 0) {\n          rulesvx += +(rule1vx / rule1cnt);\n          rulesvy += +(rule1vy / rule1cnt);\n          ++rulescnt;\n        }\n\n        // compute all rules and add it to the source velocity\n        if (rulescnt > 0) {\n          rulesvx /= rulescnt;\n          rulesvy /= rulescnt;\n          // srcvx += rulesvx;\n          // srcvy += rulesvy;\n        }\n\n        // cage the boid to the outer rectangle\n        if (false) {\n          if (srcvx < 0 && (srcx + srcvx) < srch) {\n            srcvx = +mathf64_abs(srcvx);\n          }\n          else if (srcvx > 0 && (vpwidth - (srcx + srcvx)) < srcw) {\n            srcvx = +(-(srcvx));\n          }\n          if (srcvy < 0 && (srcy + srcvy) < srch) {\n            srcvy = +mathf64_abs(srcvy);\n          }\n          else if (srcvy > 0 && (vpheight - (srcy + srcvy)) < srch) {\n            srcvy = +(-(srcvy));\n          }\n        }\n        else {\n          const maxx = +(+srch * +(mathf64_PI * mathf64_PI));\n          const newx = +(+srcx + +srcvx);\n          if (srcvx < 0) {\n            const rdistx = +(+maxx - +newx);\n            if (+rdistx > 0) {\n              const distx = +(maxx - rdistx);\n              if (+distx < +srch)\n                srcvx = +mathf64_abs(srcvx);\n              else {\n                color = 'red'\n                //const t = +(distx / maxx);\n                //srcvx = +((1.0 - t) * srcvx);\n                //srcvy = +(t * srcvy);\n              }\n            }\n          }\n          else if (srcvx > 0) {\n            const rdistx = +(newx - (vpwidth - maxx));\n            if (+rdistx > 0) {\n              const distx = +(maxx - rdistx);\n              if (+distx < +srch) {\n                srcvx = +(-(srcvx));\n              }\n              else {\n                color = 'red';\n              }\n            }\n          }\n          if (srcvy < 0 && (srcy + srcvy) < srch) {\n            srcvy = +mathf64_abs(srcvy);\n          }\n          else if (srcvy > 0 && (vpheight - (srcy + srcvy)) < srch) {\n            srcvy = +(-(srcvy));\n          }\n        }\n\n        //const srcvx = mathf64_cos(newangle) * newmag;\n        //const srcvy = mathf64_sin(newangle) * newmag;\n\n        srcx += +srcvx;\n        srcy += +srcvy;\n        srca = +float64_theta(+srcvx, +srcvy); // +mathf64_atan2(srcvy, srcvx);\n\n        // save boid state\n        nboidsf[isrc] = srcx;\n        nboidsf[isrc + 1] = srcy;\n        nboidsf[isrc + 2] = srcvx;\n        nboidsf[isrc + 3] = srcvy;\n        nboidsf[isrc + 4] = srca;\n        nboidsf[isrc + 5] = srch;\n\n        // draw the boid\n        callback(srcx, srcy, srch, srcw, srca, color);\n      }\n\n      // we are done processing\n      // flip buffers (something funny with rollup...)\n      isBuffer1 = buf1 ? false : true;\n\n    }\n    paint(ctx, size, properties, args) {\n\n      // rollup optimization strangness fix\n      const buf1 = isBuffer1;\n\n      // get current buffer\n      const boidsf = buf1 ? boidsfBuffer1 : boidsfBuffer2;\n      \n      // the view angle of the boid looking forward.\n      const viewAngle = 270 * (mathf64_PI / 180);\n      const minViewAngle = (-viewAngle) / 2; // -viewingAngle / 2\n      const maxViewAngle = (+viewAngle) / 2; // +viewingAngle / 2\n\n      // indexof the other boids\n      let idst = 0;\n      // indexof and variables for the current boid\n      let isrc = 0; let srcx = 0.0, srcy = 0.0, srcvx = 0.0, srcvy = 0.0, srcrad = 0.0;\n      // aggregated velocity for the separation rule\n      let rule1cnt = 0; let rule1vx = 0.0, rule1vy = 0.0;\n      // aggregated velocity of the alignment rule\n      let rule2cnt = 0; let rule2vx = 0.0, rule2vy = 0.0;\n      // median position of the cohesion rule\n      let rule3cnt = 0; let rule3x = 0.0, rule3y = 0.0;\n      // direct collision velocity.\n      let rule4cnt = 0; let rule4vx = 0.0, rule4vy = 0.0;\n      // aggregated velocities of all rules combined.\n      let rulescnt = 0; let rulesvx = 0.0; let rulesvy = 0.0;\n      \n      // clean our canvas and iterate of all boids\n      ctx.clearRect(0, 0, size.width, size.height);\n      ctx.beginPath();\n      for (isrc = 0; isrc < boidCount * structSize; isrc += structSize) {\n        //#region Process Boids\n\n        // load source boid variables from typed array\n        srcx = boidsf[isrc]; // x position\n        srcy = boidsf[isrc + 1]; // y position\n        srcvx = boidsf[isrc + 2]; // speed x-axis\n        srcvy = boidsf[isrc + 3]; // speed y-axis\n        srcrad = boidsf[isrc + 5]; // radius (TODO: radius-x and radius-y)\n        // get angle of source boid in radians\n        const srctheta = +mathf64_atan2(srcvy, srcvx);\n        const srcmag = +float64_hypot(srcvx, srcvy);\n\n        // reset separation rule\n        rule1cnt = 0; rule1vx = 0.0; rule1vy = 0.0;\n        // reset alignment rule\n        rule2cnt = 0; rule2vx = 0.0; rule2vy = 0.0;\n        // reset cohesion rule\n        rule3cnt = 0; rule3x = 0.0; rule3y = 0.0;\n        // reset collision detection rule\n        rule4cnt = 0; rule4vx = 0.0; rule4vy = 0.0;\n        // reset aggregated velocities\n        rulesvx = 0.0; rulesvy = 0.0; rulescnt = 0;\n\n        // iterate through all other boids\n        for (idst = 0; idst < boidCount * structSize; idst += structSize) {\n          if (idst !== isrc) {\n            // load the other boid variables\n            const dstx = boidsf[idst];\n            const dsty = boidsf[idst + 1];\n            const dstvx = boidsf[idst + 2];\n            const dstvy = boidsf[idst + 3];\n            const dstrad = boidsf[idst + 5];\n            const dsttheta = +mathf64_atan2(dstvy, dstvx);\n            const dstmag = +float64_hypot(dstvx, dstvy);\n\n            // calculate basic distance\n            const ldmin = srcrad + dstrad;\n            const ldx = dstx - srcx;\n            const ldy = dsty - srcy;\n            const euc2d = +float64_hypot(ldx, ldy);\n            const lux = ldx / euc2d;\n            const luy = ldy / euc2d;\n\n            // we enter when we are at least within some distance.\n            if (euc2d < ldmin * 2) {\n              \n              // collision detection\n              if (euc2d < ldmin) { // TODO: mass and velocity is not correctly transfered.\n                const angle = +mathf64_atan2(ldy, ldx);\n                const tx = +(mathf64_cos(angle) * ldmin * 1.0003);\n                const ty = +(mathf64_sin(angle) * ldmin * 1.0003);\n                const sdx = +(dstx - (srcx + tx));\n                const sdy = +(dsty - (srcy + ty));\n                const ddx = +(srcx - (dstx + tx));\n                const ddy = +(srcy - (dsty + ty));\n                const vx = +((dstrad - srcrad) * sdx + (dstrad + dstrad) * ddx) / ldmin;\n                const vy = +((dstrad - srcrad) * sdy + (dstrad + dstrad) * ddy) / ldmin;\n                const hyp = +float64_hypot(vx, vy);\n                //rule4vx += (vx / hyp) / mathf64_PI;\n                //rule4vy += (vy / hyp) / mathf64_PI;\n                rule4vx += +((lux * -1) * 0.853);\n                rule4vy += +((luy * -1) * 0.853);\n                rule4cnt++;\n                //continue;\n              }\n\n              // view angle detection\n              const spdy = (size.height - dsty) - (size.height - srcy);\n              const spx = ldx * mathf64_cos(srctheta) - spdy * mathf64_sin(srctheta);\n              const spy = ldx * mathf64_sin(srctheta) + spdy * mathf64_cos(srctheta);\n          \n              const spa = mathf64_atan2(-spy, spx);\n          \n              // within view? apply flocking rules\n              if (spa < maxViewAngle && spa > minViewAngle) {\n                //const angle = mathf64_atan2(ldy, ldx);\n                //const tx = (mathf64_cos(angle) * ldmin * 1.0003);\n                //const ty = (mathf64_sin(angle) * ldmin * 1.0003);\n                //const sdx = (dstx - (srcx + tx));\n                //const sdy = (dsty - (srcy + ty));\n                //const ddx = (srcx - (dstx + tx));\n                //const ddy = (srcy - (dsty + ty));\n                //const vx = ((dstrad - srcrad) * sdx + (dstrad + dstrad) * ddx) / ldmin;\n                //const vy = ((dstrad - srcrad) * sdy + (dstrad + dstrad) * ddy) / ldmin;\n\n                // separate\n                rule1vx += (srcvx / srcmag + (lux * -1)) / 2;\n                rule1vy += (srcvy / srcmag + (luy * -1)) / 2;\n                //rule1vx += +(((srcvx) + (+(srcx - dstx) / +euc2d)) / 2.0);\n                //rule1vy += +(((srcvy) + (+(srcy - dsty) / +euc2d)) / 2.0);\n                rule1cnt++;\n\n              // alignment\n              // TODO: add weights to its size.\n              const dstmag = float64_hypot(dstvx, dstvy);\n              rule2vx += (dstvx / dstmag);\n              rule2vy += (dstvy / dstmag);\n              rule2cnt++;\n\n              // cohesion\n                rule3x += dstx;\n                rule3y += dsty;\n                rule3cnt++;\n              }\n\n            }\n        \n            // alignment\n            //rule2vx += (dstvx);\n            //rule2vy += (dstvy);\n            //rule2cnt++;\n\n          }\n        }\n        //#endregion\n\n        //#region aggregate rules\n        if (false && rule4cnt > 0) {\n          // collision\n          rule4vx = rule4vx / rule4cnt ;\n          rule4vy = rule4vy / rule4cnt;\n\n          srcvx += rule4vx;\n          srcvy += rule4vy;\n          srcvx /= 2;\n          srcvy /= 2;\n        }\n        else {\n          rulesvx = 0; //srcvx;\n          rulesvy = 0; //srcvy;\n          rulescnt = 0;\n          if (rule1cnt > 0) {\n            // separate\n            rulesvx += (rule1vx / rule1cnt);\n            rulesvy += (rule1vy / rule1cnt);\n            rulescnt++;\n          }\n          if (rule2cnt > 0) {\n            // alignment\n            rulesvx += (rule2vx / rule2cnt) * 0.13;\n            rulesvy += (rule2vy / rule2cnt) * 0.13;\n            rulescnt++;\n          }\n          if (rule3cnt > 0) {\n            // cohesion\n            const vx = ((rule3x / rule3cnt) - srcx);\n            const vy = ((rule3y / rule3cnt) - srcy);\n            const nm = float64_hypot(vx, vy);\n            rulesvx += (srcvx + (vx / nm)) / mathf64_PI;\n            rulesvy += (srcvy + (vy / nm)) / mathf64_PI;\n            rulescnt++;\n          }\n          if (rule4cnt > 0) {\n            // collision\n            rulesvx = (rule4vx / rule4cnt);\n            rulesvy = (rule4vy / rule4cnt);\n            rulescnt++;\n          }\n          if (rulescnt > 0) {\n            rulesvx /= rulescnt;\n            rulesvy /= rulescnt;\n            srcvx += (rulesvx);// * 0.03; // / (mathf64_PI * mathf64_PI));\n            srcvy += (rulesvy);// * 0.03; // / (mathf64_PI * mathf64_PI));\n          }\n        }\n\n        //#endregion\n\n        //#region limit source boid\n\n        // limit speed of boid\n        const newmag = +float64_hypot(srcvx, srcvy);\n        if (newmag > CONST_DEFAULT_SPEED_LIMIT) {\n          srcvx = (srcvx / newmag) * CONST_DEFAULT_SPEED_LIMIT;\n          srcvy = (srcvy / newmag) * CONST_DEFAULT_SPEED_LIMIT;\n        }\n\n        // cage boid to outer rectangle\n        if (true) {\n          if (srcvx < 0 && (srcx + srcvx) < srcrad) {\n            srcvx = +mathf64_abs(srcvx);\n          }\n          else if (srcvx > 0 && (size.width - (srcx + srcvx)) < srcrad) {\n            srcvx = -(srcvx);\n          }\n          if (srcvy < 0 && (srcy + srcvy) < srcrad) {\n            srcvy = +mathf64_abs(srcvy);\n          }\n          else if (srcvy > 0 && (size.height - (srcy + srcvy)) < srcrad) {\n            srcvy = -(srcvy);\n          }\n        }\n        else {\n          if (srcx + srcvx < 0) {\n            srcx = size.width - (srcx - srcvx);\n          }\n          else if (srcx + srcvx > size.width) {\n            srcx = (srcx + srcvx) - size.width;\n          }\n          if (srcy + srcvy < 0) {\n            srcy = size.height - (srcy - srcvy);\n          }\n          else if (srcy + srcvy > size.height) {\n            srcy = (srcy + srcvy) - size.height;\n          }\n        }\n\n        //#endregion\n\n        // update position\n        srcx += srcvx;\n        srcy += srcvy;\n\n        // save boid state\n        boidsf[isrc] = srcx;\n        boidsf[isrc + 1] = srcy;\n        boidsf[isrc + 2] = srcvx;\n        boidsf[isrc + 3] = srcvy;\n        boidsf[isrc + 5] = srcrad;\n\n        //#region draw boid\n        if (rule4cnt > 0) ctx.fillStyle = 'red';\n        else if (rule1cnt > 0) ctx.fillStyle = `green`;\n        else if (rule2cnt > 0) ctx.fillStyle = `yellow`;\n        else if (rule3cnt > 0) ctx.fillStyle = `purple`;\n        else ctx.fillStyle = 'blue';\n\n        ctx.save()\n\n        ctx.translate(srcx, srcy)\n        ctx.rotate(mathf64_atan2(srcvy, srcvx));\n  \n        ctx.beginPath();\n\n        // const boidlength = CONST_DEFAULT_BOID_RADIUS * 3.45;\n        // const bdi = boidlength/72\n        // ctx.lineTo(-boidlength/4, bdi)\n        // ctx.lineTo(-boidlength/3, bdi)\n        // ctx.lineTo(-boidlength/2, boidlength/6)\n        // ctx.lineTo(-boidlength/2, -boidlength/6)\n        // ctx.lineTo(-boidlength/3, -bdi)\n        // ctx.lineTo(-boidlength / 4, -bdi)\n        \n        // ctx.fill();\n\n        //ctx.moveTo(srcx, srcy);\n        //ctx.arc(0, 0, srcrad, 0, 2 * mathf64_PI, false);\n        ctx.ellipse(0, 0, srcrad, srcrad / 2, 0, 0, mathf64_PI * 2);\n        ctx.fill();\n        //ctx.moveTo(srcx, srcy);\n        //ctx.lineTo(rule1vx, rule1vy);\n        //ctx.stroke();\n        // ctx.moveTo(srcx, srcy);\n        //ctx.lineTo(srcx + rule1vx, srcy + rule1vy);\n\n        // ctx.closePath();\n\n        ctx.restore();\n        //#endregion\n\n      }\n      // ctx.fillStyle = 'orange';\n      // ctx.fill();\n      //ctx.lineWidth = 1;\n      //ctx.strokeStyle = '#003300';\n      //ctx.stroke();\n    }\n  }\n\n  return new BoidsImpl();\n}\n","import createBoids from \"./boids\";\n\nfunction main() {\n  const canvas = document.getElementById('boids-canvas');\n  const ctx = canvas.getContext('2d');\n\n  const boids = createBoids({ width: canvas.clientWidth, height: canvas.clientHeight });\n  requestAnimationFrame(function draw(now) {\n    requestAnimationFrame(draw);\n    canvas.width = canvas.clientWidth;\n    canvas.height = canvas.clientHeight;\n    if (false) {\n\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.beginPath();\n\n      boids.processFrame(\n        { width: canvas.clientWidth, height: canvas.clientHeight },\n        function drawBoid(x = 0.0, y = 0.0, w = 0.0, h = 0.0, a = 0.0, color = 'blue') {\n          ctx.save();\n          ctx.translate(x, y);\n          ctx.rotate(a);\n          ctx.beginPath();\n          ctx.fillStyle = color;\n          ctx.ellipse(0, 0, w, h, 0, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.restore();\n        }\n      );\n    }\n    else\n      boids.paint(ctx, { width: canvas.clientWidth, height: canvas.clientHeight });\n  });\n}\n\nmain();\n"],"names":[],"mappings":"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"}