{"version":3,"file":"index.js","sources":["../../futils/dist/index.js","../src/boids.js","../src/index.js"],"sourcesContent":["const int_MULTIPLIER = 10000;\n\nfunction int_sqrtEx(n = 0) {\n  n = n|0;\n  return (int_MULTIPLIER * Math.sqrt(n))|0;\n}\n\nfunction int_sqrt$1(n = 0) {\n  n = n|0;\n  return Math.sqrt(n)|0;\n}\n\nfunction int_fib(n = 0) {\n  n = n|0;\n  let c = 0;\n  let x = 1;\n  let i = 1;\n  for (; i !== n; i += 1) {\n    const t = (c + x)|0;\n    c = x|0;\n    x = t|0;\n  }\n  return c|0;\n}\n\nfunction int_norm(value = 0, min = 0, max = 0) {\n  value = value|0; min = min|0; max = max|0;\n  return ((value - min) / (max - min))|0;\n}\n\nfunction int_lerp(norm = 0, min = 0, max = 0) {\n  norm = norm|0; min = min|0; max = max|0;\n  return ((max - min) * (norm + min))|0;\n}\n\nfunction int_map(value = 0, smin = 0, smax = 0, dmin = 0, dmax = 0) {\n  value = value|0; smin = smin|0; smax = smax|0; dmin = dmin|0; dmax = dmax|0;\n  return int_lerp(int_norm(value, smin, smax), dmin, dmax)|0;\n}\n\nfunction int_clamp(value = 0, min = 0, max = 0) {\n  value = value|0; min = min|0; max = max|0;\n  return Math.min(Math.max(value, Math.min(min, max)), Math.max(min, max))|0;\n}\nfunction int_clampu(value = 0, min = 0, max = 0) {\n  value = value|0; min = min|0; max = max|0;\n  return Math.min(Math.max(value, min), max)|0;\n}\n\nfunction int_inRange(value = 0, min = 0, max = 0) {\n  value = value|0; min = min|0; max = max|0;\n  return ((value >= Math.min(min, max)) &&\n          (value <= Math.max(min, max)))|0;\n}\n\nfunction int_intersectsRange(smin = 0, smax = 0, dmin = 0, dmax = 0) {\n  smin = smin|0; smax = smax|0; dmin = dmin|0; dmax = dmax|0;\n  return ((Math.max(smin, smax) >= Math.min(dmin, dmax)) && \n          (Math.min(smin, smax) <= Math.max(dmin, dmax)))|0;\n}\n\nfunction int_intersectsRect(ax = 0, ay = 0, aw = 0, ah = 0, bx = 0, by = 0, bw = 0, bh = 0) {\n  ax = ax|0; ay = ay|0; aw = aw|0; ah = ah|0; bx = bx|0; by = by|0; bw = bw|0; bh = bh|0;\n  return ((int_intersectsRange(ax|0, (ax + aw)|0, bx|0, (bx + bw)|0) > 0) &&\n          (int_intersectsRange(ay|0, (ay + ah)|0, by|0, (by + bh)|0) > 0))|0;\n}\n\nfunction int_mag2(dx = 0, dy = 0) {\n  dx = dx|0; dy = dy|0;\n  return ((dx * dx) + (dy * dy))|0;\n}\n\nfunction int_hypot(dx = 0, dy = 0) {\n  dx = dx|0; dy = dy|0;\n  return int_sqrt$1((dx * dx) + (dy * dy))|0;\n}\n\nfunction int_hypotEx(dx = 0, dy = 0) {\n  dx = dx|0; dy = dy|0;\n  return int_sqrtEx((dx * dx) + (dy * dy))|0;\n}\n\nfunction int_dot(ax = 0, ay = 0, bx = 0, by = 0) {\n  ax = ax|0; ay = ay|0; bx = bx|0; by = by|0;\n  return ((ax * bx) + (ay * by))|0;\n}\n\nfunction int_cross(ax = 0, ay = 0, bx = 0, by = 0) {\n  ax = ax|0; ay = ay|0; bx = bx|0; by = by|0;\n  return ((ax * by) - (bx * ay))|0;\n}\n\n//#region trigonometry\n\nconst int_PI = (Math.PI * int_MULTIPLIER)|0;\nconst int_PI2 = (int_PI * 2)|0;\nconst int_PI_A = ((4 / Math.PI) * int_MULTIPLIER)|0;\nconst int_PI_B = ((4 / (Math.PI * Math.PI)) * int_MULTIPLIER)|0;\n\nfunction int_toRadianEx(degrees = 0) {\n  degrees = degrees|0;\n  return ((degrees * int_PI) / 180)|0;\n}\n\nfunction int_toDegreesEx(radians = 0) {\n  radians = radians|0;\n  return ((int_MULTIPLIER * radians * 180) / int_PI)|0;\n}\n\nfunction int_wrapRadians(r = 0) {\n  r = r|0;\n  if (r > int_PI) return (r - int_PI2)|0;\n  else if (r < -int_PI) return (r + int_PI2)|0;\n  return r|0;\n}\n\nfunction int_sinLpEx(r = 0) {\n  r = r|0;\n  return ((r < 0)\n    ? (int_PI_A * r + int_PI_B * r * r)\n    : (int_PI_A * r - int_PI_B * r * r))|0;\n}\n\nfunction int_sinLp(r = 0) {\n  r = r|0;\n  //always wrap input angle between -PI and PI\n  return int_sinLpEx(int_wrapRadians(r))|0;\n}\n\nconst def_vec2i = Object.seal({ x: 0, y: 0 });\nconst def_vec2f = Object.seal({ x: 0.0, y: 0.0 });\nconst def_vec3f = Object.seal({ x: 0.0, y: 0.0, z: 0.0 });\n\n\n/**\n * just some notes\n * \n * \nconst fastSin_B = 1.2732395; // 4/pi\nconst fastSin_C = -0.40528473; // -4 / (pi²)\nexport function fastSin(value) {\n  // See  for graph and equations\n  // https://www.desmos.com/calculator/8nkxlrmp7a\n  // logic explained here : http://devmaster.net/posts/9648/fast-and-accurate-sine-cosine\t\t\t\n      \n  return (value > 0)\n    ? fastSin_B * value - fastSin_C * value * value\n    : fastSin_B * value + fastSin_C * value * value;\n}\n\nexport function fastSin2(a) {\n  let b, c;\n  return a *= 5214\n    , c = a << 17\n    , a -= 8192\n    , a <<= 18\n    , a >>= 18\n    , a = a * a >> 12\n    , b = 19900 - (3516 * a >> 14)\n    , b = 4096 - (a * b >> 16)\n    , 0 > c && (b = -b)\n    , 2.44E-4 * b;\n};\n  \nexport function fastSin3(a) {\n  a *= 5214;\n  let b = a << 17;\n  a = a - 8192 << 18 >> 18;\n  a = a * a >> 12;\n  a = 4096 - (a * (19900 - (3516 * a >> 14)) >> 16);\n  0 > b && (a = -a);\n  return 2.44E-4 * a\n};\n\n\n */\n\nfunction vec2i(x = 0, y = 0) {\n  return { x: x|0, y: y|0 } \n}\n//#region neg\n\nfunction vec2i_neg(v = def_vec2i) {\n  return {\n    x: (-(v.x|0))|0,\n    y: (-(v.y|0))|0,\n  }\n}\nfunction vec2i_ineg(v = def_vec2i) {\n  v.x = (-(v.x|0))|0;\n  v.y = (-(v.y|0))|0;\n  return v;\n}\n\n//#endregion\n\n//#region add\n\nfunction vec2i_add(a = def_vec2i, b = def_vec2i) {\n  return {\n    x: ((a.x|0) + (b.x|0))|0,\n    y: ((a.y|0) + (b.y|0))|0,\n  }\n}\nfunction vec2i_addScalar(v = def_vec2i, scalar = 0) {\n  scalar = scalar|0;\n  return {\n    x: ((v.x|0) + scalar)|0,\n    y: ((v.y|0) + scalar)|0,\n  }\n}\nfunction vec2i_iadd(a = def_vec2i, b = def_vec2i) {\n  a.x += (b.x|0)|0;\n  a.y += (b.y|0)|0;\n  return a;\n}\nfunction vec2i_iaddScalar(v = def_vec2i, scalar = 0) {\n  scalar = scalar|0;\n  v.x += scalar;\n  v.y += scalar;\n  return v;\n}\n\n//#endregion\n\n//#region sub\n\nfunction vec2i_sub(a = def_vec2i, b = def_vec2i) {\n  return {\n    x: ((a.x|0) - (b.x|0))|0,\n    y: ((a.y|0) - (b.y|0))|0,\n  }\n}\nfunction vec2i_subScalar(a = def_vec2i, scalar = 0) {\n  scalar = scalar|0;\n  return {\n    x: ((a.x|0) - scalar)|0,\n    y: ((a.y|0) - scalar)|0,\n  }\n}\nfunction vec2i_isub(a = def_vec2i, b = def_vec2i) {\n  a.x -= (b.x|0)|0;\n  a.y -= (b.y|0)|0;\n  return a;\n}\nfunction vec2i_isubScalar(v = def_vec2i, scalar = 0) {\n  scalar = scalar|0;\n  v.x -= scalar;\n  v.y -= scalar;\n  return v;\n}\n\n//#endregion\n\n//#region mul\n\nfunction vec2i_mul(a = def_vec2i, b = def_vec2i) {\n  return {\n    x: ((a.x|0) * (b.x|0))|0,\n    y: ((a.y|0) * (b.y|0))|0,\n  }\n}\nfunction vec2i_mulScalar(v = def_vec2i, scalar = 0) {\n  scalar = scalar|0;\n  return {\n    x: ((v.x|0) * scalar)|0,\n    y: ((v.y|0) * scalar)|0,\n  }\n}\nfunction vec2i_imul(a = def_vec2i, b = def_vec2i) {\n  a.x *= (b.x|0)|0;\n  a.y *= (b.y|0)|0;\n  return a;\n}\nfunction vec2i_imulScalar(v = def_vec2i, scalar = 0) {\n  scalar = scalar|0;\n  v.x *= scalar;\n  v.y *= scalar;\n  return v;\n}\n\n//#endregion\n\n//#region div\n\nfunction vec2i_div(a = def_vec2i, b = def_vec2i) {\n  return {\n    x: ((a.x|0) / (b.x|0))|0,\n    y: ((a.y|0) / (b.y|0))|0,\n  }  \n}\nfunction vec2i_divScalar(v = def_vec2i, scalar = 0) {\n  scalar = scalar|0;\n  return {\n    x: ((v.x|0) / scalar)|0,\n    y: ((v.y|0) / scalar)|0,\n  }\n}\n\nfunction vec2i_idiv(a = def_vec2i, b = def_vec2i) {\n  a.x /= b.x|0;\n  a.y /= b.y|0;\n  return a;\n}\nfunction vec2i_idivScalar(v = def_vec2i, scalar = 0) {\n  scalar = scalar|0;\n  v.x /= scalar;\n  v.y /= scalar;\n  return v;\n}\n\n\n//#endregion\n\n//#region mag2, dot and cross products\n\nfunction vec2i_mag2(v = def_vec2i) {\n  return (((v.x|0) * (v.x|0)) + ((v.y|0) * (v.y|0)))|0;\n}\n\nfunction vec2i_dot(a = def_vec2i, b = def_vec2i) {\n  return (((a.x|0) * (b.x|0)) + ((a.y|0) * (b.y|0)))|0;\n}\n\nfunction vec2i_cross(a = def_vec2i, b = def_vec2i) {\n  return (((a.x|0) * (b.y|0)) - ((a.x|0) * (b.y|0)))|0;\n}\n\nfunction vec2i_cross3(a = def_vec2i, b = def_vec2i, c = def_vec2i) {\n  return (\n    (((b.x|0) - (a.x|0)) * ((c.y|0) - (a.y|0))) -\n    (((b.y|0) - (a.y|0)) * ((c.x|0) - (a.x|0))) );\n}\n\n//#endregion\n\n//#region magnitude and normalize\n\nfunction vec2i_mag(v = def_vec2i) {\n  return int_sqrt(vec2i_mag2(v)|0)|0;\n}\nfunction vec2i_norm(v = def_vec2i) {\n  return vec2i_divScalar(v, vec2i_mag(v)|0)|0;\n}\nfunction vec2i_inorm(v = def_vec2i) {\n  return vec2i_idivScalar(v, vec2i_mag(v)|0)|0;\n}\n\n//#endregion\n\n//#region rotation\n\nfunction vec2i_thetaEx(v = def_vec2i) {\n  return (int_MULTIPLIER * Math.atan2((v.y|0), (v.x|0)))|0;\n}\nconst vec2i_angleEx = vec2i_thetaEx;\n\nfunction vec2i_phiEx(v= def_vec2i) {\n  return (int_MULTIPLIER * Math.asin((v.y|0) / vec2i_mag(v)));\n}\n\nfunction vec2i_rotn90(v = def_vec2i) {\n  return {\n    x: v.y|0,\n    y: (-(v.x|0))|0,\n  };\n}\nfunction vec2i_irotn90(v = def_vec2i) {\n  const t = v.x|0;\n  v.x = v.y|0;\n  v.y = (-(t))|0;\n  return v|0;\n}\n\nfunction vec2i_rot90(v = def_vec2i) {\n  return {\n    x: (-(v.y|0))|0,\n    y: v.x|0,\n  };\n}\nconst vec2i_perp = vec2i_rot90;\n\nfunction vec2i_irot90(v = def_vec2i) {\n  const t = v.y|0;\n  v.x = (-(t))|0;\n  v.y = (v.x|0);\n  return v|0;\n}\nconst vec2i_iperp = vec2f_irot90;\n\n//#endregion\n\n/**\n * Tests if triangle intersects with a rectangle\n * \n * @param {*} v1 \n * @param {*} v2 \n * @param {*} v3 \n * @param {*} r1 \n * @param {*} r2 \n * @returns {boolean} true if they intersect.\n */\nfunction vec2i_triangleIntersect(v1, v2, v3, r1, r2) {\n  /*\n    This function borrowed faithfully from a wonderfl (:3) discussion on\n    calculating triangle collision with AABBs on the following blog:\n    http://sebleedelisle.com/2009/05/super-fast-trianglerectangle-intersection-test/\n  \n    This particular optimization best suits my purposes and was contributed\n    to the discussion by someone from http://lab9.fr/\n    */\n  \n    const l = r1.x|0;\n    const r = r2.x|0;\n    const t = r1.y|0;\n    const b = r2.y|0;\n  \n    const x0 = v1.x|0;\n    const y0 = v1.y|0;\n    const x1 = v2.x|0;\n    const y1 = v2.y|0;\n    const x2 = v3.x|0;\n    const y2 = v3.y|0;\n  \n    const b0 = (((x0 > l) ? 1 : 0) | (((y0 > t) ? 1 : 0) << 1) |\n        (((x0 > r) ? 1 : 0) << 2) | (((y0 > b) ? 1 : 0) << 3))|0;\n    if (b0 == 3) return true;\n  \n    const b1 = ((x1 > l) ? 1 : 0) | (((y1 > t) ? 1 : 0) << 1) |\n        (((x1 > r) ? 1 : 0) << 2) | (((y1 > b) ? 1 : 0) << 3);\n    if (b1 == 3) return true;\n  \n    const b2 = ((x2 > l) ? 1 : 0) | (((y2 > t) ? 1 : 0) << 1) |\n        (((x2 > r) ? 1 : 0) << 2) | (((y2 > b) ? 1 : 0) << 3);\n    if (b2 == 3) return true;\n  \n    let c = 0;\n    let m = 0;\n    let s = 0;\n  \n    const i0 = (b0 ^ b1)|0;\n    if (i0 != 0) {\n        m = ((y1-y0) / (x1-x0))|0;\n        c = (y0 -(m * x0))|0;\n        if (i0 & 1) { s = m * l + c; if ( s > t && s < b) return true; }\n        if (i0 & 2) { s = (t - c) / m; if ( s > l && s < r) return true; }\n        if (i0 & 4) { s = m * r + c; if ( s > t && s < b) return true; }\n        if (i0 & 8) { s = (b - c) / m; if ( s > l && s < r) return true; }\n    }\n  \n    const i1 = (b1 ^ b2)|0;\n    if (i1 != 0) {\n        m = ((y2 - y1) / (x2 - x1))|0;\n        c = (y1 -(m * x1))|0;\n        if (i1 & 1) { s = m * l + c; if ( s > t && s < b) return true; }\n        if (i1 & 2) { s = (t - c) / m; if ( s > l && s < r) return true; }\n        if (i1 & 4) { s = m * r + c; if ( s > t && s < b) return true; }\n        if (i1 & 8) { s = (b - c) / m; if ( s > l && s < r) return true; }\n    }\n  \n    const i2 = (b0 ^ b2)|0;\n    if (i2 != 0)\n    {\n        m = ((y2 - y0) / (x2 - x0))|0;\n        c = (y0 -(m * x0))|0;\n        if (i2 & 1) { s = m * l + c; if ( s > t && s < b) return true; }\n        if (i2 & 2) { s = (t - c) / m; if ( s > l && s < r) return true; }\n        if (i2 & 4) { s = m * r + c; if ( s > t && s < b) return true; }\n        if (i2 & 8) { s = (b - c) / m; if ( s > l && s < r) return true; }\n    }\n  \n    return false;\n  }\n\nfunction float_sqrt(n = 0.0) {\n  n = +n;\n  return +Math.sqrt(+n);\n}\n\nconst float_isqrt = (function() {\n  const f = new Float32Array(1);\n  const i = new Int32Array(f.buffer);\n  return function float_isqrt_impl(n = 0.0) {\n    n = +n;\n    const n2 = +(n * 0.5);\n    f[0] = +n;\n    i[0] = (0x5f375a86 - (i[0]|0 >> 1))|0;\n    n = +f[0];\n    return +(+n * +(1.5 - (+n2 * +n * +n)));\n  };\n})();\n\nfunction float_fib(n = 0.0) {\n  n = +n;\n  let c = 0.0;\n  let x = 1.0;\n  let i = 1.0;\n  for (; i !== x; i += 1.0) {\n    const t = +(+c + +x);\n    c = +x;\n    x = +t;\n  }\n  return +c;\n}\n\n// https://gist.github.com/geraldyeo/988116export \nconst float_sqrtFive = +Math.sqrt(5);\nfunction float_fib2(n = 0.0) {\n  n = +n;\n  const fh = +(1.0 / +float_sqrtFive * +Math.pow(+(+(1.0 + float_sqrtFive ) / 2.0), +n));\n  const sh = +(1.0 / +float_sqrtFive * +Math.pow(+(+(1.0 - float_sqrtFive ) / 2.0), +n));\n  return +Math.round(fh - sh);\n}\n\nfunction float_norm(value = 0.0, min = 0.0, max = 0.0) {\n  return +(+(+value - +min) / +(+max - +min));\n}\n\nfunction float_lerp(norm = 0.0, min = 0.0, max = 0.0) {\n  return +(+(+max - +min) * +(+norm + +min));\n}\n\nfunction float_map(value = 0.0, smin = 0.0, smax = 0.0, dmin = 0.0, dmax = 0.0) {\n  return +float_lerp(+float_norm(+value, +smin, +smax), +dmin, +dmax);\n}\n\n/**\n * Clamps a value between a checked boudary.\n * and can therefor handle swapped min/max arguments\n * \n * @param {float} value input value\n * @param {float} min minimum bounds\n * @param {float} max maximum bounds\n * @returns {float} clamped value \n */\nfunction float_clamp(value = 0.0, min = 0.0, max = 0.0) {\n  return +Math.min(+Math.max(+value, +Math.min(+min, +max)), +Math.max(+min, +max));\n}\n/**\n * Clamps a value between an unchecked boundary\n * this function needs min < max!!\n * (see float_clamp for a checked boundary)\n * \n * @param {float} value input value\n * @param {float} min minimum bounds\n * @param {float} max maximum bounds\n * @returns {float} clamped value \n */\nfunction float_clampu(value = 0.0, min = 0.0, max = 0.0) {\n  return +Math.min(+Math.max(+value, +min), +max);\n}\n\nfunction float_inRange(value = 0.0, min = 0.0, max = 0.0) {\n  return +(+value >= +Math.min(+min, +max) && +value <= +Math.max(+min, +max));\n}\n\nfunction float_intersectsRange(smin = 0.0, smax = 0.0, dmin = 0.0, dmax = 0.0) {\n  return +(+Math.max(+smin, +smax) >= +Math.min(+dmin, +dmax) && \n           +Math.min(+smin, +smax) <= +Math.max(+dmin, +dmax));\n}\n\nfunction float_intersectsRect(ax = 0.0, ay = 0.0, aw = 0.0, ah = 0.0, bx = 0.0, by = 0.0, bw = 0.0, bh = 0.0) {\n  return +(+(+float_intersectsRange(+ax, +(+ax + +aw), +bx, +(+bx + +bw)) > 0.0 &&\n             +float_intersectsRange(+ay, +(+ay + +ah), +by, +(+by + +bh)) > 0.0));\n}\n\nfunction float_mag2(dx = 0.0, dy = 0.0) {\n  return +(+(+dx * +dx) + +(+dy * +dy));\n}\n\nfunction float_hypot(dx = 0.0, dy = 0.0) {\n  return +Math.sqrt(+(+(+dx * +dx) + +(+dy * +dy)));\n}\n\n/**\n * \n * We can calculate the Dot Product of two vectors this way:\n * \n *    a · b = |a| × |b| × cos(θ)\n * \n * or in this implementation as:\n * \n *    a · b = ax × bx + ay × by\n * \n * When two vectors are at right angles to each other the dot product is zero.\n * \n * @param {float} ax vector A x velocity \n * @param {float} ay vector A y velocity\n * @param {float} bx vector B x velocity\n * @param {float} by vector B y velocity\n * @returns {float} scalar of the dot product\n */\nfunction float_dot(ax = 0.0, ay = 0.0, bx = 0.0, by = 0.0) {\n  return +(+(+ax * +bx) + +(+ay * +by));\n}\n\n/**\n * \n * The Cross Product Magnitude\n * a × b of two vectors is another vector that is at right angles to both:\n * The magnitude (length) of the cross product equals the area of a parallelogram with vectors a and b for sides:\n * \n * We can calculate the Cross Product this way:\n * \n *    a × b = |a| |b| sin(θ) n\n * \n * or as\n * \n *    a × b = ax × by - bx × ay \n * \n * Another useful property of the cross product is,\n * that its magnitude is related to the sine of\n * the angle between the two vectors:\n *  \n *    | a x b | = |a| . |b| . sine(theta)\n *\n * or\n *\n *    sine(theta) = | a x b | / (|a| . |b|)\n *\n * So, in implementation 1 above, if a and b are known in advance to be unit vectors then the result of that function is exactly that sine() value.\n * @param {float} ax \n * @param {float} ay \n * @param {float} bx \n * @param {float} by \n */\nfunction float_cross(ax = 0.0, ay = 0.0, bx = 0.0, by = 0.0) {\n  return +(+(+ax * +by) - +(+bx * +ay));\n}\n\n//#region trigonometry\n\nconst float_PIx2 = Math.PI * 2; // 6.28318531\nconst float_PIh = Math.PI / 2; // 1.57079632\nconst float_PI_A = 4 / Math.PI; // 1.27323954\nconst float_PI_B = 4 / (Math.PI * Math.PI); // 0.405284735\n\nfunction float_toRadian(degrees = 0.0) {\n  return +(+degrees * +Math.PI / 180.0);\n}\n\nfunction float_toDegrees(radians = 0.0) {\n  return +(+radians * 180.0 / +Math.PI);\n}\n\nfunction float_wrapRadians(r = 0.0) {\n  r = +r;\n  if (+r > Math.PI) return +(+r - +float_PIx2);\n  else if (+r < -Math.PI) return +(+r + +float_PIx2);\n  return +r;\n}\n\nfunction float_sinLpEx(r = 0.0) {\n  r = +r;\n  return +((r < 0.0)\n    ? +(+float_PI_A * +r + +float_PI_B * +r * +r)\n    : +(+float_PI_A * +r - +float_PI_B * +r * +r));\n}\n\nfunction float_sinLp(r = 0.0) {\n  //always wrap input angle between -PI and PI\n  return +float_sinLpEx(+float_wrapRadians(+r));\n}\n\nfunction float_cosLp(r = 0.0) {\n  //compute cosine: sin(x + PI/2) = cos(x)\n  return +float_sinLp(+(+r + +float_PIh));\n}\n\nfunction float_cosHp(r = 0.0) {\n//   template<typename T>\n// inline T cos(T x) noexcept\n// {\n//     constexpr T tp = 1./(2.*M_PI);\n//     x *= tp;\n//     x -= T(.25) + std::floor(x + T(.25));\n//     x *= T(16.) * (std::abs(x) - T(.5));\n//     #if EXTRA_PRECISION\n//     x += T(.225) * x * (std::abs(x) - T(1.));\n//     #endif\n//     return x;\n// }\n  throw new Error(\"float_cosHp is not implemented!\");\n}\n\nfunction float_sinMpEx(r = 0.0) {\n  r = +r;\n  const sin = +((r < 0.0)\n    ? +(float_PI_A * r + float_PI_B * r * r)\n    : +(float_PI_A * r - float_PI_B * r * r));\n  return +((sin < 0.0)\n    ? +(0.225 * (sin * -sin - sin) + sin)\n    : +(0.225 * (sin *  sin - sin) + sin));\n}\n\nfunction float_sinMp(r = 0.0) {\n  return +float_sinHpEx(+float_wrapRadians(+r));\n}\nfunction float_cosMp(r = 0.0) {\n  //compute cosine: sin(x + PI/2) = cos(x)\n  return +float_sinHp(+(+r + +float_PIh));\n}\n\nfunction float_theta(y = 0.0, x = 0.0) {\n  return +Math.atan2(+y, +x);\n  /*\n    // alternative was faster, but not anymore.\n    // error < 0.005\n    y = +y;\n    x = +x;\n    if (x == 0.0) {\n      if (y > 0.0) return +(Math.PI / 2.0);\n      if (y == 0.0) return 0.0;\n      return +(-Math.PI / 2.0);\n    }\n\n    const z = +(y / x);\n    var atan = 0.0;\n    if (+Math.abs(z) < 1.0) {\n      atan = +(z / (1.0 + 0.28 * z * z));\n      if (x < 0.0) {\n        if (y < 0.0) return +(atan - Math.PI);\n        return +(atan + Math.PI);\n      }\n    }\n    else {\n      atan = +(Math.PI / 2.0 - z / (z * z + 0.28));\n      if (y < 0.0) return +(atan - Math.PI);\n    }\n    return +(atan);\n  */\n}\nconst float_angle = float_theta;\n\nfunction float_phi(y = 0.0, length = 0.0) {\n  return +Math.asin(+y / +length);\n}\n\n//#endregion\n\nfunction vec2f(x = 0.0, y = 0.0) { return { x: +x, y: +y } }\n//#region neg\n\nfunction vec2f_neg(v = def_vec2f) {\n  return {\n    x: +(-(+v.x)),\n    y: +(-(+v.y)),\n  }\n}\nfunction vec2f_ineg(v = def_vec2f) {\n  v.x = +(-(+v.x));\n  v.y = +(-(+v.y));\n  return v;\n}\n\n//#endregion\n\n//#region add\n\nfunction vec2f_add(a = def_vec2f, b = def_vec2f) {\n  return {\n    x: +(+a.x + +b.x),\n    y: +(+a.y + +b.y),\n  }\n}\nfunction vec2f_addScalar(v = def_vec2f, scalar = 0.0) {\n  return {\n    x: +(+v.x + +scalar),\n    y: +(+v.y + +scalar),\n  }\n}\nfunction vec2f_iadd(a = def_vec2f, b = def_vec2f) {\n  a.x += +(+b.x);\n  a.y += +(+b.y);\n  return a;\n}\nfunction vec2f_iaddScalar(v = def_vec2f, scalar = 0.0) {\n  v.x += +scalar;\n  v.y += +scalar;\n  return v;\n}\n\n//#endregion\n\n//#region sub\n\nfunction vec2f_sub(a = def_vec2f, b = def_vec2f) {\n  return {\n    x: +(+a.x - +b.x),\n    y: +(+a.y - +b.y),\n  }\n}\nfunction vec2f_subScalar(a = def_vec2f, scalar = 0.0) {\n  return {\n    x: +(+a.x - +scalar),\n    y: +(+a.y - +scalar),\n  }\n}\nfunction vec2f_isub(a = def_vec2f, b = def_vec2f) {\n  a.x -= +(+b.x);\n  a.y -= +(+b.y);\n  return a;\n}\nfunction vec2f_isubScalar(v = def_vec2f, scalar = 0.0) {\n  v.x -= +scalar;\n  v.y -= +scalar;\n  return v;\n}\n\n//#endregion\n\n//#region mul\n\nfunction vec2f_mul(a = def_vec2f, b = def_vec2f) {\n  return {\n    x: +(+a.x * +b.x),\n    y: +(+a.y * +b.y),\n  }\n}\nfunction vec2f_mulScalar(v = def_vec2f, scalar = 0.0) {\n  return {\n    x: +(+v.x * +scalar),\n    y: +(+v.y * +scalar),\n  }\n}\nfunction vec2f_imul(a = def_vec2f, b = def_vec2f) {\n  a.x *= +(+b.x);\n  a.y *= +(+b.y);\n  return a;\n}\nfunction vec2f_imulScalar(v = def_vec2f, scalar = 0.0) {\n  v.x *= +scalar;\n  v.y *= +scalar;\n  return v;\n}\n\n//#endregion\n\n//#region div\n\nfunction vec2f_div(a = def_vec2f, b = def_vec2f) {\n  return {\n    x: +(+a.x / +b.x),\n    y: +(+a.y / +b.y),\n  }  \n}\nfunction vec2f_divScalar(v = def_vec2f, scalar = 0.0) {\n  return {\n    x: +(+v.x / +scalar),\n    y: +(+v.y / +scalar),\n  }\n}\n\nfunction vec2f_idiv(a = def_vec2f, b = def_vec2f) {\n  a.x /= +(+b.x);\n  a.y /= +(+b.y);\n  return a;\n}\nfunction vec2f_idivScalar$1(v = def_vec2f, scalar = 0.0) {\n  v.x /= +scalar;\n  v.y /= +scalar;\n  return v;\n}\n\n\n//#endregion\n\n//#region mag2, dot and cross products\n\nfunction vec2f_mag2(v = def_vec2f) {\n  return +(+(+v.x * +v.x) + +(+v.y * +v.y));\n}\nfunction vec2f_dot(a = def_vec2f, b = def_vec2f) {\n  return +(+(+a.x * +b.x) + +(+a.y * +b.y));\n}\n\n/**\n * Returns the cross-product of two vectors\n *\n * @param {vec2f} vector A \n * @param {vec2f} vector B\n * @returns {double} The cross product of two vectors\n */\nfunction vec2f_cross(a = def_vec2f, b = def_vec2f) {\n  return +(+(+a.x * + +b.y) - +(+a.x * + +b.y));\n}\n\n/**\n * Returns the cross-product of three vectors\n * \n * You can determine which side of a line a point is on\n * by converting the line to hyperplane form (implicitly\n * or explicitly) and then computing the perpendicular\n * (pseudo)distance from the point to the hyperplane.\n * \n * With the crossproduct of two vectors A and B being the vector\n * \n * AxB = (AyBz − AzBy, AzBx − AxBz, AxBy − AyBx)\n * with Az and Bz being zero you are left with the third component of that vector\n * \n *    AxBy - AyBx\n * \n * With A being the vector from point a to b, and B being the vector from point a to c means\n * \n *    Ax = (b[x]-a[x])\n *    Ay = (b[y]-a[y])\n *    Bx = (c[x]-a[x])\n *    By = (c[y]-a[y])\n * \n * giving\n * \n *    AxBy - AyBx = (b[x]-a[x])*(c[y]-a[y])-(b[y]-a[y])*(c[x]-a[x])\n * \n * which is a scalar, the sign of that scalar will tell you wether point c lies to the left or right of vector ab\n * \n * @param {vec2f} vector A\n * @param {vec2f} vector B\n * @param {vec2f} vector C\n * @returns {double} The cross product of three vectors\n * \n */\nfunction vec2f_cross3(a = def_vec2f, b = def_vec2f, c = def_vec2f) {\n  return +(\n    +(+(+b.x - +a.x) * +(+c.y - +a.y)) -\n    +(+(+b.y - +a.y) * +(+c.x - +a.x)) );\n}\n\n//#endregion\n\n//#region magnitude and normalize\n\nfunction vec2f_mag(v = def_vec2f) {\n  return +Math.sqrt(+vec2f_mag2(v));\n}\nfunction vec2f_norm(v = def_vec2f) {\n  return vec2f_divScalar(v, +vec2f_mag(v));\n}\nfunction vec2f_inorm(v = def_vec2f) {\n  return vec2f_idivScalar$1(v, +vec2f_mag(v));\n}\n\n//#endregion\n\n//#region rotation\n\n/**\n * Returns the angle in radians of its vector\n *\n * Math.atan2(dy, dx) === Math.asin(dy/Math.sqrt(dx*dx + dy*dy))\n * \n * @param {} v Vector\n */\nfunction vec2f_theta(v = def_vec2f) {\n  return +Math.atan2(+v.y, +v.x);\n}\nconst vec2f_angle = vec2f_theta;\n\nfunction vec2f_phi(v = def_vec2f) {\n  return +Math.asin(+v.y / +vec2f_mag(v));\n}\n\nfunction vec2f_rotn90(v = def_vec2f) {\n  return {\n    x: +(+v.y),\n    y: +(-(+v.x)),\n  };\n}\nfunction vec2f_irotn90(v = def_vec2f) {\n  const t = +v.x;\n  v.x = +(+v.y);\n  v.y = +(-(+t));\n  return v;\n}\n\nfunction vec2f_rot90(v = def_vec2f) {\n  return {\n    x: +(-(+v.y)),\n    y: +(+v.x),\n  };\n}\nconst vec2f_perp = vec2f_rot90;\n\nfunction vec2f_irot90$1(v = def_vec2f) {\n  const t = +v.y;\n  v.x = +(-(+t));\n  v.y = +(+v.x);\n  return v;\n}\nconst vec2f_iperp = vec2f_irot90$1;\n\n/**\n * Rotates a vector by the specified angle in radians\n * \n * @param {vec2f} v vector \n * @param {float} r  angle in radians\n * @returns {vec2f} transformed output vector\n */\nfunction vec2f_rotate(v = def_vec2f, r = 0.0) {\n  return {\n    x: +(+(+v.x * +Math.cos(+r)) - +(+v.y * +Math.sin(+r))),\n    y: +(+(+v.x * +Math.sin(+r)) + +(+v.y * +Math.cos(+r))),\n  }\n}\nfunction vec2f_irotate(v = def_vec2f, r = 0.0) {\n  const vx = +v.x;\n  const vy = +v.y;\n  v.x = +(+(+vx * +Math.cos(+r)) - +(+vy * +Math.sin(+r)));\n  v.y = +(+(+vx * +Math.sin(+r)) + +(+vy * +Math.cos(+r)));\n  return v;\n}\n\nfunction vec2f_rotateAbout(v = def_vec2f, r = 0.0, p = def_vec2f) {\n  return {\n    x: +(+p.x + +(+(+v.x - +p.x) * +Math.cos(+r)) - +(+(+v.y - +p.y) * +Math.sin(+r))),\n    y: +(+p.y + +(+(+v.x - +p.x) * +Math.sin(+r)) + +(+(+v.y - +p.y) * +Math.cos(+r))),\n  }\n}\nfunction vec2f_irotateAbout(v = def_vec2f, r = 0.0, p = def_vec2f) {\n  const vx = +v.x;\n  const vy = +v.y;\n  v.x = +(+p.x + +(+(+vx - +p.x) * +Math.cos(+r)) - +(+(+vy - +p.y) * +Math.sin(+r)));\n  v.y = +(+p.y + +(+(+vx - +p.x) * +Math.sin(+r)) + +(+(+vy - +p.y) * +Math.cos(+r)));\n  return v;\n}\n\n/**\n * Rotates a vector by the specified angle in radians\n * \n * @param {vec2f} v vector \n * @param {float} r  angle in radians\n * @returns {vec2f} transformed output vector\n */\nfunction vec2f_rotateEx(v = def_vec2f, r = 0.0, sin = Math.sin, cos = Math.cos) {\n  return {\n    x: +(+(+v.x * +cos(+r)) - +(+v.y * +sin(+r))),\n    y: +(+(+v.x * +sin(+r)) + +(+v.y * +cos(+r))),\n  }\n}\nfunction vec2f_irotateEx(v = def_vec2f, r = 0.0, sin = Math.sin, cos = Math.cos) {\n  const vx = +v.x;\n  const vy = +v.y;\n  v.x = +(+(+vx * +cos(+r)) - +(+vy * +sin(+r)));\n  v.y = +(+(+vx * +sin(+r)) + +(+vy * +cos(+r)));\n  return v;\n}\n\nfunction vec2f_rotateAboutEx(v = def_vec2f, r = 0.0, p = def_vec2f, sin = Math.sin, cos = Math.cos) {\n  return {\n    x: +(+p.x + +(+(+v.x - +p.x) * +cos(+r)) - +(+(+v.y - +p.y) * +sin(+r))),\n    y: +(+p.y + +(+(+v.x - +p.x) * +sin(+r)) + +(+(+v.y - +p.y) * +cos(+r))),\n  }\n}\nfunction vec2f_irotateAboutEx(v = def_vec2f, r = 0.0, p = def_vec2f, sin = Math.sin, cos = Math.cos) {\n  const vx = +v.x;\n  const vy = +v.y;\n  v.x = +(+p.x + +(+(+vx - +p.x) * +cos(+r)) - +(+(+vy - +p.y) * +sin(+r)));\n  v.y = +(+p.y + +(+(+vx - +p.x) * +sin(+r)) + +(+(+vy - +p.y) * +cos(+r)));\n  return v;\n}\n\n//#endregion\n\n//#region collision\n\n/**\n * Tests if triangle intersects with rectangle\n * \n * @param {*} l1 \n * @param {*} l2 \n * @param {*} l3 \n * @param {*} r1 \n * @param {*} r2 \n * @param {*} normal \n */\nfunction vec2f_intersectTriangleRect(l1 = def_vec2f, l2 = def_vec2f, l3 = def_vec2f, r1 = def_vec2f, r2 = def_vec2f, normal = 1.0) {\n  normal = +normal;\n  const dx = +(+r2.x - +r1.x);\n  const dy = +(+r2.y - +r1.y);\n  return !(\n    (((+l1.x - +r1.x) * dy - (+l1.y - +r1.y) * dx) * normal < 0) ||\n    (((+l2.x - +r1.x) * dy - (+l2.y - +r1.y) * dx) * normal < 0) ||\n    (((+l3.x - +r1.x) * dy - (+l3.y - +r1.y) * dx) * normal < 0));\n}\n\n/**\n * Tests if 2 triangles intersect\n * \n * @param {*} l1 \n * @param {*} l2 \n * @param {*} l3 \n * @param {*} r1 \n * @param {*} r2 \n * @param {*} r3 \n */\nfunction vec2f_intersectTriangles(l1 = def_vec2f, l2 = def_vec2f, l3 = def_vec2f, r1 = def_vec2f, r2 = def_vec2f, r3 = def_vec2f) {\n  const lnorm = +(+(+(+l2.x - +l1.x) * +(+l3.y - +l1.y))\n              - +(+(+l2.y - +l1.y) * +(+l3.x - +l1.x)));\n  const rnorm = +(+(+(+r2.x - +r1.x) * +(+r3.y - +r1.y))\n              - +(+(+r2.y - +r1.y) * +(+r3.x - +r1.x)));\n  return !(vec2f_intersectTriangleRect(r1, r2, r3, l1, l2, lnorm)\n    || vec2f_intersectTriangleRect(r1, r2, r3, l2, l3, lnorm)\n    || vec2f_intersectTriangleRect(r1, r2, r3, l3, l1, lnorm)\n    || vec2f_intersectTriangleRect(l1, l2, l3, r1, r2, rnorm)\n    || vec2f_intersectTriangleRect(l1, l2, l3, r2, r3, rnorm)\n    || vec2f_intersectTriangleRect(l1, l2, l3, r3, r1, rnorm));\n}\n\n//#endregion\n\nfunction vec3f(x = 0.0, y = 0.0 , z = 0.0) {\n  return { x: +x, y: +y, z: +z };\n}\n\nfunction vec3f_toVec2(v = def_vec3f) {\n  return { x: +v.x, y: +v.y };\n}\n\nfunction vec3f_fromVec2(v = def_vec2f) {\n  return { x: +v.x, y: +v.y, z: 0.0 };\n}\n\nfunction vec3f_dub(v = def_vec3f) {\n  return { x: +v.x, y: +v.y, z: +v.z };\n}\n\n//#region div\n\nfunction vec3f_div(a = def_vec3f, b = def_vec3f) {\n  return {\n    x: +(+a.x / +b.x),\n    y: +(+a.y / +b.y),\n    z: +(+a.z / +b.z),\n  }  \n}\nfunction vec3f_divScalar(v = def_vec3f, scalar = 0.0) {\n  return {\n    x: +(+v.x / +scalar),\n    y: +(+v.y / +scalar),\n    z: +(+v.z / +scalar),\n  }\n}\n\nfunction vec3f_idiv(a = def_vec3f, b = def_vec3f) {\n  a.x /= +(+b.x);\n  a.y /= +(+b.y);\n  a.z /= +(+b.z);\n  return a;\n}\nfunction vec3f_idivScalar(v = def_vec3f, scalar = 0.0) {\n  v.x /= +scalar;\n  v.y /= +scalar;\n  v.z /= +scalar;\n  return v;\n}\n\n//#endregion\n\n//#region magnitude and normalize\n\nfunction vec3f_mag2(v = def_vec3f) {\n  return +(+(+v.x * +v.x) + +(+v.y * +v.y) + +(+v.z * +v.z));\n}\n\nfunction vec3f_mag(v = def_vec3f) {\n  return +Math.sqrt(+vec3f_mag2(v));\n}\nfunction vec3f_norm(v = def_vec3f) {\n  return vec3f_divScalar(v, +vec3f_mag(v));\n}\nfunction vec3f_inorm(v = def_vec3f) {\n  return vec2f_idivScalar(v, +vec3f_mag(v));\n}\n\n//#endregion\n\nfunction vec3f_crossABAB(a = def_vec3f, b = def_vec3f\n  ) {\n  return {\n    x: +(+(+a.y * +b.z) - +(+a.z * +b.y)),\n    y: +(+(+a.z * +b.x) - +(+a.x * +b.z)),\n    z: +(+(+a.x * +b.y) - +(+a.y * +b.x)),\n  }\n}\n\nexport { float_PI_A, float_PI_B, float_PIh, float_PIx2, float_angle, float_clamp, float_clampu, float_cosHp, float_cosLp, float_cosMp, float_cross, float_dot, float_fib, float_fib2, float_hypot, float_inRange, float_intersectsRange, float_intersectsRect, float_isqrt, float_lerp, float_mag2, float_map, float_norm, float_phi, float_sinLp, float_sinLpEx, float_sinMp, float_sinMpEx, float_sqrt, float_sqrtFive, float_theta, float_toDegrees, float_toRadian, float_wrapRadians, int_MULTIPLIER, int_PI, int_PI2, int_PI_A, int_PI_B, int_clamp, int_clampu, int_cross, int_dot, int_fib, int_hypot, int_hypotEx, int_inRange, int_intersectsRange, int_intersectsRect, int_lerp, int_mag2, int_map, int_norm, int_sinLp, int_sinLpEx, int_sqrt$1 as int_sqrt, int_sqrtEx, int_toDegreesEx, int_toRadianEx, int_wrapRadians, vec2f, vec2f_add, vec2f_addScalar, vec2f_angle, vec2f_cross, vec2f_cross3, vec2f_div, vec2f_divScalar, vec2f_dot, vec2f_iadd, vec2f_iaddScalar, vec2f_idiv, vec2f_idivScalar$1 as vec2f_idivScalar, vec2f_imul, vec2f_imulScalar, vec2f_ineg, vec2f_inorm, vec2f_intersectTriangleRect, vec2f_intersectTriangles, vec2f_iperp, vec2f_irot90$1 as vec2f_irot90, vec2f_irotate, vec2f_irotateAbout, vec2f_irotateAboutEx, vec2f_irotateEx, vec2f_irotn90, vec2f_isub, vec2f_isubScalar, vec2f_mag, vec2f_mag2, vec2f_mul, vec2f_mulScalar, vec2f_neg, vec2f_norm, vec2f_perp, vec2f_phi, vec2f_rot90, vec2f_rotate, vec2f_rotateAbout, vec2f_rotateAboutEx, vec2f_rotateEx, vec2f_rotn90, vec2f_sub, vec2f_subScalar, vec2f_theta, vec2i, vec2i_add, vec2i_addScalar, vec2i_angleEx, vec2i_cross, vec2i_cross3, vec2i_div, vec2i_divScalar, vec2i_dot, vec2i_iadd, vec2i_iaddScalar, vec2i_idiv, vec2i_idivScalar, vec2i_imul, vec2i_imulScalar, vec2i_ineg, vec2i_inorm, vec2i_iperp, vec2i_irot90, vec2i_irotn90, vec2i_isub, vec2i_isubScalar, vec2i_mag, vec2i_mag2, vec2i_mul, vec2i_mulScalar, vec2i_neg, vec2i_norm, vec2i_perp, vec2i_phiEx, vec2i_rot90, vec2i_rotn90, vec2i_sub, vec2i_subScalar, vec2i_thetaEx, vec2i_triangleIntersect, vec3f, vec3f_crossABAB, vec3f_div, vec3f_divScalar, vec3f_dub, vec3f_fromVec2, vec3f_idiv, vec3f_idivScalar, vec3f_inorm, vec3f_mag, vec3f_mag2, vec3f_norm, vec3f_toVec2 };\n","import { float_hypot } from 'futilsjs';\n\nexport class Boids {\n}\n\nconst CONST_DEFAULT_BOID_RADIUS = 21.5;\nconst CONST_DEFAULT_SPEED_LIMIT = Math.PI / 3;\n\nfunction initBoidsf(f64arr) {\n  // get current buffer\n  const boidsf = isBuffer1 ? boidsfBuffer1 : boidsfBuffer2;\n\n  // init boids randomly\n  for (let isrc = 0; isrc < boidCount * structSize; isrc += structSize) {\n    // x-position\n    boidsf[isrc] = Math.random() * viewport.width; // srcx\n    // y-position\n    boidsf[isrc + 1] = Math.random() * viewport.height; // srcy\n    // x-velocity\n    boidsf[isrc + 2] = +Math.sin(Math.random() * Math.PI * 2) * CONST_DEFAULT_SPEED_LIMIT;\n    // y-velocity\n    boidsf[isrc + 3] = +Math.sin(Math.random() * Math.PI * 2) * CONST_DEFAULT_SPEED_LIMIT;\n    // angle in unsigned radians\n    boidsf[isrc + 4] = (Math.random() * Math.PI * 2) - Math.PI;\n    // unsigned radiusX or width\n    boidsf[isrc + 5] = +Math.max(3, Math.abs(Math.sin((Math.random() * Math.PI * 2) - Math.PI)) * CONST_DEFAULT_BOID_RADIUS);\n    boidsf[isrc + 6] = 0;\n  }\n}\n\nexport default function createBoids(viewport = {}, boidCount = 52, maxSize = 254) {\n\n  const structSize = 7;\n  //const boids = new Int32Array(maxSize * structSize);\n  const boidsfBuffer1 = new Float64Array(maxSize * structSize); // boids.buffer);\n  const boidsfBuffer2 = new Float64Array(maxSize * structSize); // boids.buffer);\n  // setup buffer selector\n  let isBuffer1 = true;\n\n  initBoidsf(boidsfBuffer1);\n\n  class BoidsImpl {\n    paint(ctx, size, properties, args) {\n      // get current buffer\n      const boidsf = isBuffer1 ? boidsfBuffer1 : boidsfBuffer2;\n\n      // init separation rule\n      let rule1vx = 0.0;\n      let rule1vy = 0.0;\n      let rule1cnt = 0;\n\n      // clean our canvas and iterate of all boids\n      ctx.clearRect(0, 0, size.width, size.height);\n      ctx.beginPath();\n      for (let isrc = 0; isrc < boidCount * structSize; isrc += structSize) {\n        const srcx = +boidsf[isrc]; // x position\n        const srcy = +boidsf[isrc + 1]; // y position\n        const srcvx = +boidsf[isrc + 2]; // x velocity\n        const srcvy = +boidsf[isrc + 3]; // y velocity\n        const srcangle = +boidsf[isrc + 4]; // angle (derived from vx/vy when mag > 0.0)\n        const srch = +boidsf[isrc + 5]; // height/radiusY\n        const srcw = +(srch / 2.0);  // width/radiusX\n        const srcm = +(srch * srcw) * 0.639; // mass\n\n        // iterate through other boids\n        for (let ioth = 0; ioth < boidCount * structSize; ioth += structSize) {\n          if (ioth !== isrc) {\n            // load the other boid variables\n            const othx = +boidsf[ioth];\n            const othy = +boidsf[ioth + 1];\n            const othvx = +boidsf[ioth + 2];\n            const othvy = +boidsf[ioth + 3];\n            const othangle = +boidsf[ioth + 4];\n            const othh = +boidsf[ioth + 5]; // height/radiusY\n            const othw = +(othh / 2.0); // width/radiusX\n            const othm = +(othh * othw) * 0.639; // mass\n\n            const distx = +(othx - srcx);\n            const disty = +(othy - srcy);\n            const distance = +float_hypot(distx, disty);\n\n            const minwidth = +(srcw + othw);\n            const minheight = +(srch + othh);\n            const mindist = +float_hypot(minwidth, minheight);\n            const maxdist = +(mindist * Math.PI);\n            if (distance < maxdist) {\n              \n              //#region RULE 1: Separation\n\n              // compute unit normal and tangent vectors\n              const unx = +(distx / distance); // unit normal vector x\n              const uny = +(disty / distance); // unit normal vector y\n              const utx = +(-uny); // unit tangent vector x\n              const uty = +(unx); // unit tangent vector y\n              \n              // compute scalar projection of velocities\n              const svn = +Float_dot2x2(unx, uny, srcvx, srcvy);\n              const svt = +Float_dot2x2(utx, uty, srcvx, srcvy);\n              const ovn = +Float_dot2x2(unx, uny, othvx, othvy);\n              // const ovt = +Float_dot2x2(utx, uty, othvx, othvy);\n\n              // compute new velocity using 1 dimension\n              const svp = +((svn * (srcm - othm) + 2.0 * othm * ovn) / (srcm + othm));\n              // const ovp = +((ovn * (othm - srcm) + 2.0 * srcm * svn) / (srcm + othm));\n              \n              // compute new normal and tangent velocity vectors\n              const nnx = +(svp * unx); // nnv = svp * unv\n              const nny = +(svp * uny);\n              const ntx = +(svt * utx); // ntv = svt * utv;\n              const nty = +(svt * uty);\n              const nvx = +(nnx + ntx); // nvv = nnv + ntv;\n              const nvy = +(nny + nty);\n\n              // compute weights relative to distance\n              const reldist = +(1.0 / (+Math.abs(distance - mindist) + 1.0)); \n              rule1vx += +(nvx * reldist);\n              rule1vy += +(nvy * reldist);\n              rule1cnt++;\n\n              //#endregion\n              \n            }\n          }\n        }\n\n        let newangle = srcangle;\n        let newmag = srcmag;\n\n        //const srcvx = Math.cos(newangle) * newmag;\n        //const srcvy = Math.sin(newangle) * newmag;\n        const newx = srcx + srcvx;\n        const newy = srcy + srcvy;\n\n        // save boid state\n        boidsf[isrc] = newx;\n        boidsf[isrc + 1] = newy;\n        boidsf[isrc + 2] = newangle;\n        boidsf[isrc + 3] = newmag;\n\n        // draw the boid\n        ctx.save();\n        ctx.translate(newx, newy);\n        ctx.rotate(newangle);\n        ctx.beginPath();\n        ctx.fillStyle = 'blue';\n        ctx.ellipse(0, 0, srcradw, srcradh, 0, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.restore();\n      }\n    }\n    paint2(ctx, size, properties, args) {\n      // the view angle of the boid looking forward.\n      const viewAngle = 270 * (Math.PI / 180);\n      const minViewAngle = (-viewAngle) / 2; // -viewingAngle / 2\n      const maxViewAngle = (+viewAngle) / 2; // +viewingAngle / 2\n\n      // indexof the other boids\n      let idst = 0;\n      // indexof and variables for the current boid\n      let isrc = 0; let srcx = 0.0, srcy = 0.0, srcvx = 0.0, srcvy = 0.0, srcrad = 0.0;\n      // aggregated velocity for the separation rule\n      let rule1cnt = 0; let rule1vx = 0.0, rule1vy = 0.0;\n      // aggregated velocity of the alignment rule\n      let rule2cnt = 0; let rule2vx = 0.0, rule2vy = 0.0;\n      // median position of the cohesion rule\n      let rule3cnt = 0; let rule3x = 0.0, rule3y = 0.0;\n      // direct collision velocity.\n      let rule4cnt = 0; let rule4vx = 0.0, rule4vy = 0.0;\n      // aggregated velocities of all rules combined.\n      let rulescnt = 0; let rulesvx = 0.0; let rulesvy = 0.0;\n      \n      // clean our canvas and iterate of all boids\n      ctx.clearRect(0, 0, size.width, size.height);\n      ctx.beginPath();\n      for (isrc = 0; isrc < boidCount * structSize; isrc += structSize) {\n        //#region Process Boids\n\n        // load source boid variables from typed array\n        srcx = boidsf[isrc]; // x position\n        srcy = boidsf[isrc + 1]; // y position\n        srcvx = boidsf[isrc + 2]; // speed x-axis\n        srcvy = boidsf[isrc + 3]; // speed y-axis\n        srcrad = boidsf[isrc + 4]; // radius (TODO: radius-x and radius-y)\n        // get angle of source boid in radians\n        const srctheta = +Math.atan2(srcvy, srcvx);\n        const srcmag = +float_hypot(srcvx, srcvy);\n\n        // reset separation rule\n        rule1cnt = 0; rule1vx = 0.0; rule1vy = 0.0;\n        // reset alignment rule\n        rule2cnt = 0; rule2vx = 0.0; rule2vy = 0.0;\n        // reset cohesion rule\n        rule3cnt = 0; rule3x = 0.0; rule3y = 0.0;\n        // reset collision detection rule\n        rule4cnt = 0; rule4vx = 0.0; rule4vy = 0.0;\n        // reset aggregated velocities\n        rulesvx = 0.0; rulesvy = 0.0; rulescnt = 0;\n\n        // iterate through all other boids\n        for (idst = 0; idst < boidCount * structSize; idst += structSize) {\n          if (idst !== isrc) {\n            // load the other boid variables\n            const dstx = boidsf[idst];\n            const dsty = boidsf[idst + 1];\n            const dstvx = boidsf[idst + 2];\n            const dstvy = boidsf[idst + 3];\n            const dstrad = boidsf[idst + 4];\n            const dsttheta = +Math.atan2(dstvy, dstvx);\n            const dstmag = +float_hypot(dstvx, dstvy);\n\n            // calculate basic distance\n            const ldmin = srcrad + dstrad;\n            const ldx = dstx - srcx;\n            const ldy = dsty - srcy;\n            const euc2d = +float_hypot(ldx, ldy);\n            const lux = ldx / euc2d;\n            const luy = ldy / euc2d;\n\n            // we enter when we are at least within some distance.\n            if (euc2d < ldmin * 2) {\n              \n              // collision detection\n              if (euc2d < ldmin) { // TODO: mass and velocity is not correctly transfered.\n                const angle = Math.atan2(ldy, ldx);\n                const tx = (Math.cos(angle) * ldmin * 1.0003);\n                const ty = (Math.sin(angle) * ldmin * 1.0003);\n                const sdx = (dstx - (srcx + tx));\n                const sdy = (dsty - (srcy + ty));\n                const ddx = (srcx - (dstx + tx));\n                const ddy = (srcy - (dsty + ty));\n                const vx = ((dstrad - srcrad) * sdx + (dstrad + dstrad) * ddx) / ldmin;\n                const vy = ((dstrad - srcrad) * sdy + (dstrad + dstrad) * ddy) / ldmin;\n                const hyp = float_hypot(vx, vy);\n                //rule4vx += (vx / hyp) / Math.PI;\n                //rule4vy += (vy / hyp) / Math.PI;\n                rule4vx += (lux * -1) * 0.853;\n                rule4vy += (luy * -1) * 0.853;\n                rule4cnt++;\n                //continue;\n              }\n\n              // view angle detection\n              const spdy = (size.height - dsty) - (size.height - srcy);\n              const spx = ldx * Math.cos(srctheta) - spdy * Math.sin(srctheta);\n              const spy = ldx * Math.sin(srctheta) + spdy * Math.cos(srctheta);\n          \n              const spa = Math.atan2(-spy, spx);\n          \n              // within view? apply flocking rules\n              if (spa < maxViewAngle && spa > minViewAngle) {\n                //const angle = Math.atan2(ldy, ldx);\n                //const tx = (Math.cos(angle) * ldmin * 1.0003);\n                //const ty = (Math.sin(angle) * ldmin * 1.0003);\n                //const sdx = (dstx - (srcx + tx));\n                //const sdy = (dsty - (srcy + ty));\n                //const ddx = (srcx - (dstx + tx));\n                //const ddy = (srcy - (dsty + ty));\n                //const vx = ((dstrad - srcrad) * sdx + (dstrad + dstrad) * ddx) / ldmin;\n                //const vy = ((dstrad - srcrad) * sdy + (dstrad + dstrad) * ddy) / ldmin;\n\n                // separate\n                rule1vx += (srcvx / srcmag + (lux * -1)) / 2;\n                rule1vy += (srcvy / srcmag + (luy * -1)) / 2;\n                //rule1vx += +(((srcvx) + (+(srcx - dstx) / +euc2d)) / 2.0);\n                //rule1vy += +(((srcvy) + (+(srcy - dsty) / +euc2d)) / 2.0);\n                rule1cnt++;\n\n              // alignment\n              // TODO: add weights to its size.\n              const dstmag = float_hypot(dstvx, dstvy);\n              rule2vx += (dstvx / dstmag);\n              rule2vy += (dstvy / dstmag);\n              rule2cnt++;\n\n              // cohesion\n                rule3x += dstx;\n                rule3y += dsty;\n                rule3cnt++;\n              }\n\n            }\n        \n            // alignment\n            //rule2vx += (dstvx);\n            //rule2vy += (dstvy);\n            //rule2cnt++;\n\n          }\n        }\n        //#endregion\n\n        //#region aggregate rules\n        if (false && rule4cnt > 0) {\n          // collision\n          rule4vx = rule4vx / rule4cnt ;\n          rule4vy = rule4vy / rule4cnt;\n\n          srcvx += rule4vx;\n          srcvy += rule4vy;\n          srcvx /= 2;\n          srcvy /= 2;\n        }\n        else {\n          rulesvx = 0; //srcvx;\n          rulesvy = 0; //srcvy;\n          rulescnt = 0;\n          if (rule1cnt > 0) {\n            // separate\n            rulesvx += (rule1vx / rule1cnt);\n            rulesvy += (rule1vy / rule1cnt);\n            rulescnt++;\n          }\n          if (rule2cnt > 0) {\n            // alignment\n            rulesvx += (rule2vx / rule2cnt) * 0.13;\n            rulesvy += (rule2vy / rule2cnt) * 0.13;\n            rulescnt++;\n          }\n          if (rule3cnt > 0) {\n            // cohesion\n            const vx = ((rule3x / rule3cnt) - srcx);\n            const vy = ((rule3y / rule3cnt) - srcy);\n            const nm = float_hypot(vx, vy);\n            rulesvx += (srcvx + (vx / nm)) / Math.PI;\n            rulesvy += (srcvy + (vy / nm)) / Math.PI;\n            rulescnt++;\n          }\n          if (rule4cnt > 0) {\n            // collision\n            rulesvx = (rule4vx / rule4cnt);\n            rulesvy = (rule4vy / rule4cnt);\n            rulescnt++;\n          }\n          if (rulescnt > 0) {\n            rulesvx /= rulescnt;\n            rulesvy /= rulescnt;\n            srcvx += (rulesvx);// * 0.03; // / (Math.PI * Math.PI));\n            srcvy += (rulesvy);// * 0.03; // / (Math.PI * Math.PI));\n          }\n        }\n\n        //#endregion\n\n        //#region limit source boid\n\n        // limit speed of boid\n        const newmag = +float_hypot(srcvx, srcvy);\n        if (newmag > CONST_DEFAULT_SPEED_LIMIT) {\n          srcvx = (srcvx / newmag) * CONST_DEFAULT_SPEED_LIMIT;\n          srcvy = (srcvy / newmag) * CONST_DEFAULT_SPEED_LIMIT;\n        }\n\n        // cage boid to outer rectangle\n        if (true) {\n          if (srcvx < 0 && (srcx + srcvx) < srcrad) {\n            srcvx = Math.abs(srcvx);\n          }\n          else if (srcvx > 0 && (size.width - (srcx + srcvx)) < srcrad) {\n            srcvx = -(srcvx);\n          }\n          if (srcvy < 0 && (srcy + srcvy) < srcrad) {\n            srcvy = Math.abs(srcvy);\n          }\n          else if (srcvy > 0 && (size.height - (srcy + srcvy)) < srcrad) {\n            srcvy = -(srcvy);\n          }\n        }\n        else {\n          if (srcx + srcvx < 0) {\n            srcx = size.width - (srcx - srcvx);\n          }\n          else if (srcx + srcvx > size.width) {\n            srcx = (srcx + srcvx) - size.width;\n          }\n          if (srcy + srcvy < 0) {\n            srcy = size.height - (srcy - srcvy);\n          }\n          else if (srcy + srcvy > size.height) {\n            srcy = (srcy + srcvy) - size.height;\n          }\n        }\n\n        //#endregion\n\n        // update position\n        srcx += srcvx;\n        srcy += srcvy;\n\n        // save boid state\n        boidsf[isrc] = srcx;\n        boidsf[isrc + 1] = srcy;\n        boidsf[isrc + 2] = srcvx;\n        boidsf[isrc + 3] = srcvy;\n        boidsf[isrc + 4] = srcrad;\n\n        //#region draw boid\n        if (rule4cnt > 0) ctx.fillStyle = 'red';\n        else if (rule1cnt > 0) ctx.fillStyle = `green`;\n        else if (rule2cnt > 0) ctx.fillStyle = `yellow`;\n        else if (rule3cnt > 0) ctx.fillStyle = `purple`;\n        else ctx.fillStyle = 'blue';\n\n        ctx.save()\n\n        ctx.translate(srcx, srcy)\n        ctx.rotate(Math.atan2(srcvy, srcvx));\n  \n        ctx.beginPath();\n\n        // const boidlength = CONST_DEFAULT_BOID_RADIUS * 3.45;\n        // const bdi = boidlength/72\n        // ctx.lineTo(-boidlength/4, bdi)\n        // ctx.lineTo(-boidlength/3, bdi)\n        // ctx.lineTo(-boidlength/2, boidlength/6)\n        // ctx.lineTo(-boidlength/2, -boidlength/6)\n        // ctx.lineTo(-boidlength/3, -bdi)\n        // ctx.lineTo(-boidlength / 4, -bdi)\n        \n        // ctx.fill();\n\n        //ctx.moveTo(srcx, srcy);\n        //ctx.arc(0, 0, srcrad, 0, 2 * Math.PI, false);\n        ctx.ellipse(0, 0, srcrad, srcrad / 2, 0, 0, Math.PI * 2);\n        ctx.fill();\n        //ctx.moveTo(srcx, srcy);\n        //ctx.lineTo(rule1vx, rule1vy);\n        //ctx.stroke();\n        // ctx.moveTo(srcx, srcy);\n        //ctx.lineTo(srcx + rule1vx, srcy + rule1vy);\n\n        // ctx.closePath();\n\n        ctx.restore();\n        //#endregion\n\n      }\n      // ctx.fillStyle = 'orange';\n      // ctx.fill();\n      //ctx.lineWidth = 1;\n      //ctx.strokeStyle = '#003300';\n      //ctx.stroke();\n    }\n  }\n\n  return new BoidsImpl();\n}\n","import createBoids from \"./boids\";\n\nfunction main() {\n  const canvas = document.getElementById('boids-canvas');\n  const ctx = canvas.getContext('2d');\n\n  const boids = createBoids({ width: canvas.clientWidth, height: canvas.clientHeight });\n  requestAnimationFrame(function draw(now) {\n    requestAnimationFrame(draw);\n    canvas.width = canvas.clientWidth;\n    canvas.height = canvas.clientHeight;\n    boids.paint(ctx, { width: canvas.clientWidth, height: canvas.clientHeight });\n  });\n}\n\nmain();\n"],"names":[],"mappings":"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"}